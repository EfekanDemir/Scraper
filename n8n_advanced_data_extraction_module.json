{
  "active": false,
  "createdAt": "2024-01-20T16:00:00.000Z",
  "id": "advanced_data_extraction_module",
  "name": "Advanced Data Extraction Module",
  "nodes": [
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "target_url", 
              "value": "https://example.com/scan-results"
            },
            {
              "name": "extraction_strategy",
              "value": "comprehensive"
            },
            {
              "name": "output_format",
              "value": "excel_multi_sheet"
            },
            {
              "name": "confidence_threshold",
              "value": "0.7"
            },
            {
              "name": "timeout_seconds",
              "value": "30"
            },
            {
              "name": "retry_attempts",
              "value": "3"
            }
          ],
          "boolean": [
            {
              "name": "enable_detailed_extraction",
              "value": true
            },
            {
              "name": "enable_js_extraction", 
              "value": true
            },
            {
              "name": "enable_validation",
              "value": true
            },
            {
              "name": "enable_api_scraping",
              "value": true
            }
          ]
        }
      },
      "id": "extraction_config",
      "name": "Extraction Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "functionCode": "// Session Initialization with Enhanced Structure\nconst config = $input.first().json;\nconst stepStart = Date.now();\n\ntry {\n  console.log('üöÄ Initializing Advanced Data Extraction Session');\n  \n  const session = {\n    session_id: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    config: config,\n    target_url: config.target_url,\n    start_time: new Date().toISOString(),\n    \n    // Step tracking\n    steps: {\n      session_init: { status: 'completed', timestamp: new Date().toISOString() }\n    },\n    \n    // Error and warning tracking\n    errors: [],\n    warnings: [],\n    \n    // Performance metrics\n    metrics: {\n      session_start: stepStart,\n      steps_completed: 1\n    },\n    \n    // Results structure matching Python project's 7 Excel sheets\n    results: {\n      ozet_bilgiler: [],        // Summary information\n      rakipler: [],             // Competitors\n      sponsorlu_listeler: [],   // Sponsored listings\n      detayli_sonuclar: [],     // Detailed results\n      harita_verileri: [],      // Map data\n      javascript_verileri: [],  // JavaScript data\n      api_verileri: []          // API data\n    },\n    \n    // Data containers\n    html_content: null,\n    extracted_html: null,\n    js_extracted_data: null,\n    api_responses: []\n  };\n  \n  console.log(`‚úÖ Session initialized: ${session.session_id}`);\n  console.log(`üéØ Target URL: ${session.target_url}`);\n  console.log(`üìä Results structure prepared with 7 data categories`);\n  \n  return [{ json: session }];\n  \n} catch (error) {\n  console.error('‚ùå Session Initialization Failed:', error.message);\n  throw error;\n}"
      },
      "id": "session_init",
      "name": "Session Initialization",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.target_url }}",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxRetries": 3
          },
          "redirect": {
            "followRedirect": true,
            "maxRedirect": 5
          }
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "tr-TR,tr;q=0.9,en;q=0.8"
            }
          ]
        }
      },
      "id": "fetch_html",
      "name": "Fetch HTML Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [600, 300]
    },
    {
      "parameters": {
        "functionCode": "// Advanced HTML Content Analysis and Pattern Recognition\nconst session = $input.first().json;\nconst httpResponse = $input.last().json;\n\nconst stepStart = Date.now();\n\ntry {\n  // Ensure session properties exist\n  session.steps = session.steps || {};\n  session.errors = session.errors || [];\n  session.metrics = session.metrics || {};\n  \n  // Update step status\n  session.steps.html_fetch = { status: 'completed', timestamp: new Date().toISOString() };\n  session.steps.content_analysis = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  // Extract HTML content with error handling\n  let htmlContent = '';\n  if (httpResponse && httpResponse.body) {\n    htmlContent = httpResponse.body;\n  } else if (httpResponse && httpResponse.data) {\n    htmlContent = httpResponse.data;\n  } else if (typeof httpResponse === 'string') {\n    htmlContent = httpResponse;\n  } else {\n    throw new Error('No HTML content found in response');\n  }\n\n  if (!htmlContent || htmlContent.length < 500) {\n    throw new Error(`Insufficient content for analysis: ${htmlContent.length} characters`);\n  }\n\n  console.log(`üìä HTML Content Size: ${htmlContent.length} characters`);\n\n  // Content Statistics\n  const contentStats = {\n    total_length: htmlContent.length,\n    element_count: (htmlContent.match(/<[^>]+>/g) || []).length,\n    script_count: (htmlContent.match(/<script[^>]*>/gi) || []).length,\n    table_count: (htmlContent.match(/<table[^>]*>/gi) || []).length,\n    form_count: (htmlContent.match(/<form[^>]*>/gi) || []).length,\n    div_count: (htmlContent.match(/<div[^>]*>/gi) || []).length,\n    link_count: (htmlContent.match(/<a[^>]*>/gi) || []).length\n  };\n\n  // Update session with analysis results\n  session.html_content = htmlContent;\n  session.content_stats = contentStats;\n  session.steps.content_analysis = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics.processing_time = Date.now() - stepStart;\n\n  console.log('‚úÖ Content Analysis Complete');\n  console.log(`üìä Found ${contentStats.table_count} tables, ${contentStats.script_count} scripts`);\n  console.log(`‚ö° Processing time: ${session.metrics.processing_time}ms`);\n\n  return [{ json: session }];\n\n} catch (error) {\n  // Ensure session.errors exists\n  if (!session.errors) session.errors = [];\n  \n  session.errors.push({\n    step: 'content_analysis',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('‚ùå Content Analysis Failed:', error.message);\n  throw error;\n}"
      },
      "id": "content_analysis",
      "name": "Content Analysis & Pattern Recognition",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced HTML Data Extraction with Specific Pattern Matching\nconst session = $input.first().json;\nconst stepStart = Date.now();\n\ntry {\n  const htmlContent = session.html_content;\n  if (!htmlContent) {\n    throw new Error('No HTML content available for extraction');\n  }\n  \n  console.log(`üîç Starting HTML extraction on ${htmlContent.length} characters`);\n  session.steps.html_extraction = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  const extractedData = {\n    all_tables: [],\n    sponsored_listings: [],\n    all_scripts: '',\n    hidden_inputs: [],\n    business_cards: [],\n    search_results: [],\n    meta_data: []\n  };\n  \n  console.log('üéØ Extracting all tables...');\n  // Extract all tables with better pattern matching\n  const allTablesRegex = /<table[^>]*>[\\s\\S]*?<\\/table>/gi;\n  const allTablesMatches = htmlContent.match(allTablesRegex) || [];\n  extractedData.all_tables = allTablesMatches;\n  console.log(`üìä Found ${allTablesMatches.length} total tables`);\n  \n  // Log table samples for debugging\n  allTablesMatches.forEach((table, index) => {\n    const preview = table.substring(0, 200).replace(/\\s+/g, ' ');\n    console.log(`Table ${index + 1} preview: ${preview}...`);\n  });\n  \n  console.log('üéØ Extracting business information divs...');\n  // Extract business information containers\n  const businessInfoRegex = /<div[^>]*class=\"[^\"]*(?:business|company|result|listing)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi;\n  const businessMatches = htmlContent.match(businessInfoRegex) || [];\n  extractedData.business_cards = businessMatches;\n  console.log(`üè¢ Found ${businessMatches.length} business information containers`);\n  \n  console.log('üéØ Extracting search result containers...');\n  // Extract search result containers\n  const searchResultRegex = /<div[^>]*class=\"[^\"]*(?:search-result|result-item|listing-item)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi;\n  const searchMatches = htmlContent.match(searchResultRegex) || [];\n  extractedData.search_results = searchMatches;\n  console.log(`üîç Found ${searchMatches.length} search result containers`);\n  \n  console.log('üéØ Extracting sponsored content...');\n  // Extract sponsored content with broader patterns\n  const sponsoredPatterns = [\n    /<div[^>]*class=\"[^\"]*(?:sponsored|ad|promotion|reklam)[^\"]*\"[^>]*>[\\s\\S]*?<\\/div>/gi,\n    /<span[^>]*class=\"[^\"]*sponsored[^\"]*\"[^>]*>[\\s\\S]*?<\\/span>/gi,\n    /<li[^>]*class=\"[^\"]*(?:sponsored|ad)[^\"]*\"[^>]*>[\\s\\S]*?<\\/li>/gi\n  ];\n  \n  sponsoredPatterns.forEach(pattern => {\n    const matches = htmlContent.match(pattern) || [];\n    extractedData.sponsored_listings.push(...matches);\n  });\n  console.log(`üì¢ Found ${extractedData.sponsored_listings.length} sponsored listings`);\n  \n  console.log('üéØ Extracting JavaScript content...');\n  // Extract all script content\n  const scriptRegex = /<script[^>]*>([\\s\\S]*?)<\\/script>/gi;\n  let allScripts = '';\n  let scriptMatch;\n  let scriptCount = 0;\n  while ((scriptMatch = scriptRegex.exec(htmlContent)) !== null) {\n    allScripts += scriptMatch[1] + '\\n';\n    scriptCount++;\n  }\n  extractedData.all_scripts = allScripts;\n  console.log(`üìú Extracted ${scriptCount} scripts with ${allScripts.length} characters total`);\n  \n  console.log('üéØ Extracting hidden inputs...');\n  // Extract hidden input fields with comprehensive patterns\n  const hiddenInputRegex = /<input[^>]*type=[\"']hidden[\"'][^>]*>/gi;\n  const hiddenInputMatches = htmlContent.match(hiddenInputRegex) || [];\n  hiddenInputMatches.forEach(inputHtml => {\n    const nameMatch = inputHtml.match(/name=[\"']([^\"']+)[\"']/i);\n    const valueMatch = inputHtml.match(/value=[\"']([^\"']*)[\"']/i);\n    const idMatch = inputHtml.match(/id=[\"']([^\"']+)[\"']/i);\n    \n    if (nameMatch || idMatch) {\n      extractedData.hidden_inputs.push({\n        name: nameMatch ? nameMatch[1] : '',\n        id: idMatch ? idMatch[1] : '',\n        value: valueMatch ? valueMatch[1] : ''\n      });\n    }\n  });\n  console.log(`üîí Found ${extractedData.hidden_inputs.length} hidden input fields`);\n  \n  // Log hidden inputs for debugging\n  extractedData.hidden_inputs.forEach(input => {\n    console.log(`Hidden input: ${input.name} = ${input.value}`);\n  });\n  \n  console.log('üéØ Extracting meta data...');\n  // Extract meta data and page info\n  const metaRegex = /<meta[^>]*>/gi;\n  const metaMatches = htmlContent.match(metaRegex) || [];\n  metaMatches.forEach(metaHtml => {\n    const nameMatch = metaHtml.match(/name=[\"']([^\"']+)[\"']/i);\n    const contentMatch = metaHtml.match(/content=[\"']([^\"']*)[\"']/i);\n    const propertyMatch = metaHtml.match(/property=[\"']([^\"']+)[\"']/i);\n    \n    if ((nameMatch || propertyMatch) && contentMatch) {\n      extractedData.meta_data.push({\n        name: nameMatch ? nameMatch[1] : (propertyMatch ? propertyMatch[1] : ''),\n        content: contentMatch[1]\n      });\n    }\n  });\n  \n  session.extracted_html = extractedData;\n  session.steps.html_extraction = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics.extraction_time = Date.now() - stepStart;\n  \n  console.log('‚úÖ Enhanced HTML Data Extraction Complete');\n  console.log(`üìä Extraction Summary:`);\n  console.log(`  ‚Ä¢ Tables: ${extractedData.all_tables.length}`);\n  console.log(`  ‚Ä¢ Business cards: ${extractedData.business_cards.length}`);\n  console.log(`  ‚Ä¢ Search results: ${extractedData.search_results.length}`);\n  console.log(`  ‚Ä¢ Sponsored listings: ${extractedData.sponsored_listings.length}`);\n  console.log(`  ‚Ä¢ Hidden inputs: ${extractedData.hidden_inputs.length}`);\n  console.log(`  ‚Ä¢ JavaScript chars: ${extractedData.all_scripts.length}`);\n  console.log(`‚ö° Extraction time: ${session.metrics.extraction_time}ms`);\n  \n  return [{ json: session }];\n  \n} catch (error) {\n  session.errors.push({\n    step: 'html_extraction',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('‚ùå HTML Extraction Failed:', error.message);\n  throw error;\n}"
      },
      "id": "html_extraction",
      "name": "HTML Data Extraction",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "functionCode": "// Ultra-Robust Data Processing & Assembly - Specialized for Business Scan Results\nconst session = $input.first().json;\nconst stepStart = Date.now();\n\ntry {\n  console.log('üöÄ Starting Specialized Business Data Processing...');\n  \n  session.steps.data_processing = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  const extractedHtml = session.extracted_html;\n  const htmlContent = session.html_content;\n  \n  console.log('üîç Initial Debug Info:');\n  console.log(`  ‚Ä¢ HTML content length: ${htmlContent ? htmlContent.length : 0}`);\n  console.log(`  ‚Ä¢ Tables found: ${extractedHtml?.all_tables?.length || 0}`);\n  console.log(`  ‚Ä¢ Scripts found: ${extractedHtml?.all_scripts?.length || 0}`);\n  console.log(`  ‚Ä¢ Hidden inputs: ${extractedHtml?.hidden_inputs?.length || 0}`);\n  \n  if (!htmlContent || htmlContent.length < 100) {\n    throw new Error('Insufficient HTML content for processing');\n  }\n  \n  // Specialized Business Data Extraction Functions\n  function extractBusinessSummary(content) {\n    console.log('üìã Extracting business summary information...');\n    const summaryData = [];\n    \n    // Extract scan summary table\n    const scanSummaryPatterns = [\n      /<table[^>]*class=\"[^\"]*(?:summary|scan|info|overview)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/table>/gi,\n      /<div[^>]*class=\"[^\"]*(?:summary|scan-info|overview)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi,\n      /<section[^>]*class=\"[^\"]*(?:summary|info)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/section>/gi\n    ];\n    \n    scanSummaryPatterns.forEach((pattern, patternIndex) => {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const tableContent = match[1];\n        \n        // Extract rows from table\n        const rowRegex = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n        let rowMatch;\n        let rowIndex = 0;\n        \n        while ((rowMatch = rowRegex.exec(tableContent)) !== null && rowIndex < 20) {\n          const rowContent = rowMatch[1];\n          \n          // Extract cells\n          const cellRegex = /<t[hd][^>]*>([\\s\\S]*?)<\\/t[hd]>/gi;\n          const cells = [];\n          let cellMatch;\n          \n          while ((cellMatch = cellRegex.exec(rowContent)) !== null) {\n            const cellText = cellMatch[1]\n              .replace(/<[^>]*>/g, ' ')\n              .replace(/\\s+/g, ' ')\n              .trim();\n            \n            if (cellText && cellText.length > 0) {\n              cells.push(cellText);\n            }\n          }\n          \n          if (cells.length >= 2) {\n            summaryData.push({\n              label: cells[0],\n              value: cells.slice(1).join(' | '),\n              source: 'summary_table',\n              pattern_index: patternIndex,\n              row_index: rowIndex,\n              extracted_at: new Date().toISOString()\n            });\n            \n            console.log(`  ‚Ä¢ Summary: ${cells[0]} = ${cells.slice(1).join(' | ')}`);\n          }\n          \n          rowIndex++;\n        }\n      }\n    });\n    \n    // Extract key-value pairs from spans/divs\n    const kvPatterns = [\n      /<span[^>]*class=\"[^\"]*(?:label|key)[^\"]*\"[^>]*>([^<]+)<\\/span>[\\s\\S]*?<span[^>]*class=\"[^\"]*(?:value|data)[^\"]*\"[^>]*>([^<]+)<\\/span>/gi,\n      /<div[^>]*class=\"[^\"]*(?:field|item)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi\n    ];\n    \n    kvPatterns.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(content)) !== null && summaryData.length < 50) {\n        if (match.length >= 3) {\n          const key = match[1].replace(/<[^>]*>/g, '').trim();\n          const value = match[2].replace(/<[^>]*>/g, '').trim();\n          \n          if (key && value && key.length > 0 && value.length > 0) {\n            summaryData.push({\n              label: key,\n              value: value,\n              source: 'key_value_extraction',\n              extracted_at: new Date().toISOString()\n            });\n            \n            console.log(`  ‚Ä¢ KV: ${key} = ${value}`);\n          }\n        }\n      }\n    });\n    \n    return summaryData;\n  }\n  \n  function extractCompetitors(content) {\n    console.log('üè¢ Extracting competitor information...');\n    const competitorData = [];\n    \n    // Extract competitor tables\n    const competitorPatterns = [\n      /<table[^>]*class=\"[^\"]*(?:competitor|ranking|business)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/table>/gi,\n      /<div[^>]*class=\"[^\"]*(?:competitor|business-item|listing)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi,\n      /<ul[^>]*class=\"[^\"]*(?:business|listing)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/ul>/gi\n    ];\n    \n    competitorPatterns.forEach((pattern, patternIndex) => {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const matchContent = match[1];\n        \n        if (patternIndex === 0) { // Table pattern\n          const rowRegex = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n          let rowMatch;\n          let rowIndex = 0;\n          \n          while ((rowMatch = rowRegex.exec(matchContent)) !== null && rowIndex < 100) {\n            const rowContent = rowMatch[1];\n            \n            // Skip header rows\n            if (rowContent.includes('<th') && rowIndex === 0) {\n              rowIndex++;\n              continue;\n            }\n            \n            const cellRegex = /<td[^>]*>([\\s\\S]*?)<\\/td>/gi;\n            const cells = [];\n            let cellMatch;\n            \n            while ((cellMatch = cellRegex.exec(rowContent)) !== null) {\n              const cellText = cellMatch[1]\n                .replace(/<[^>]*>/g, ' ')\n                .replace(/\\s+/g, ' ')\n                .trim();\n              \n              if (cellText && cellText.length > 0 && cellText !== '-') {\n                cells.push(cellText);\n              }\n            }\n            \n            if (cells.length >= 1) {\n              competitorData.push({\n                business_name: cells[0] || 'Unknown',\n                rank: cells[1] || null,\n                score: cells[2] || null,\n                additional_info: cells.slice(3).join(' | '),\n                source: 'competitor_table',\n                row_index: rowIndex,\n                extracted_at: new Date().toISOString()\n              });\n              \n              console.log(`  ‚Ä¢ Competitor: ${cells[0]} (Rank: ${cells[1] || 'N/A'})`);\n            }\n            \n            rowIndex++;\n          }\n        } else { // Div/List patterns\n          const itemRegex = /<(?:div|li)[^>]*>([\\s\\S]*?)<\\/(?:div|li)>/gi;\n          let itemMatch;\n          let itemIndex = 0;\n          \n          while ((itemMatch = itemRegex.exec(matchContent)) !== null && itemIndex < 50) {\n            const itemContent = itemMatch[1];\n            const itemText = itemContent\n              .replace(/<[^>]*>/g, ' ')\n              .replace(/\\s+/g, ' ')\n              .trim();\n            \n            if (itemText && itemText.length > 3) {\n              const parts = itemText.split(/[\\|\\-\\:]/).map(p => p.trim()).filter(p => p.length > 0);\n              \n              competitorData.push({\n                business_name: parts[0] || itemText,\n                additional_info: parts.slice(1).join(' | '),\n                source: 'competitor_listing',\n                pattern_index: patternIndex,\n                item_index: itemIndex,\n                extracted_at: new Date().toISOString()\n              });\n              \n              console.log(`  ‚Ä¢ Business: ${parts[0] || itemText}`);\n            }\n            \n            itemIndex++;\n          }\n        }\n      }\n    });\n    \n    return competitorData;\n  }\n  \n  function extractSponsoredListings(content) {\n    console.log('üì¢ Extracting sponsored listings...');\n    const sponsoredData = [];\n    \n    // Extract sponsored content\n    const sponsoredPatterns = [\n      /<div[^>]*class=\"[^\"]*(?:sponsored|ad|promotion|reklam)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/div>/gi,\n      /<li[^>]*class=\"[^\"]*(?:sponsored|ad)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/li>/gi,\n      /<span[^>]*class=\"[^\"]*sponsored[^\"]*\"[^>]*>([\\s\\S]*?)<\\/span>/gi,\n      /<a[^>]*class=\"[^\"]*(?:sponsored|ad)[^\"]*\"[^>]*>([\\s\\S]*?)<\\/a>/gi\n    ];\n    \n    sponsoredPatterns.forEach((pattern, patternIndex) => {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const sponsoredContent = match[1];\n        const sponsoredText = sponsoredContent\n          .replace(/<[^>]*>/g, ' ')\n          .replace(/\\s+/g, ' ')\n          .trim();\n        \n        if (sponsoredText && sponsoredText.length > 5) {\n          // Extract URL if present\n          const urlMatch = match[0].match(/href=[\"']([^\"']+)[\"']/i);\n          const url = urlMatch ? urlMatch[1] : null;\n          \n          sponsoredData.push({\n            title: sponsoredText.substring(0, 100),\n            full_text: sponsoredText,\n            url: url,\n            source: 'sponsored_content',\n            pattern_index: patternIndex,\n            extracted_at: new Date().toISOString()\n          });\n          \n          console.log(`  ‚Ä¢ Sponsored: ${sponsoredText.substring(0, 50)}...`);\n        }\n      }\n    });\n    \n    // Look for sponsored indicators in text\n    const sponsoredIndicators = [\n      /sponsored?[\\s:]*([^<\\n]{10,100})/gi,\n      /reklam[\\s:]*([^<\\n]{10,100})/gi,\n      /advertisement[\\s:]*([^<\\n]{10,100})/gi\n    ];\n    \n    sponsoredIndicators.forEach(pattern => {\n      let match;\n      while ((match = pattern.exec(content)) !== null && sponsoredData.length < 20) {\n        const sponsoredText = match[1].trim();\n        \n        if (sponsoredText && sponsoredText.length > 10) {\n          sponsoredData.push({\n            title: sponsoredText,\n            source: 'sponsored_text_indicator',\n            extracted_at: new Date().toISOString()\n          });\n          \n          console.log(`  ‚Ä¢ Sponsored Text: ${sponsoredText}`);\n        }\n      }\n    });\n    \n    return sponsoredData;\n  }\n  \n  function extractMapData(content) {\n    console.log('üó∫Ô∏è Extracting map and location data...');\n    const mapData = [];\n    \n    // Extract coordinate-like data\n    const coordinatePatterns = [\n      /lat(?:itude)?[\"']?\\s*[:=]\\s*[\"']?([\\d\\.\\-]+)[\"']?/gi,\n      /lng|lon(?:gitude)?[\"']?\\s*[:=]\\s*[\"']?([\\d\\.\\-]+)[\"']?/gi,\n      /coordinates?[\"']?\\s*[:=]\\s*[\"']?([\\d\\.\\-,\\s]+)[\"']?/gi\n    ];\n    \n    coordinatePatterns.forEach((pattern, patternIndex) => {\n      let match;\n      while ((match = pattern.exec(content)) !== null) {\n        const coordValue = match[1].trim();\n        \n        if (coordValue && /[\\d\\.]/.test(coordValue)) {\n          mapData.push({\n            type: patternIndex === 0 ? 'latitude' : patternIndex === 1 ? 'longitude' : 'coordinates',\n            value: coordValue,\n            source: 'coordinate_extraction',\n            extracted_at: new Date().toISOString()\n          });\n          \n          console.log(`  ‚Ä¢ Coordinate: ${coordValue}`);\n        }\n      }\n    });\n    \n    // Extract location information from hidden inputs\n    if (extractedHtml?.hidden_inputs) {\n      extractedHtml.hidden_inputs.forEach(input => {\n        if (input.name && input.value) {\n          const locationFields = ['lat', 'lng', 'lon', 'coord', 'location', 'address', 'place'];\n          const isLocationField = locationFields.some(field => \n            input.name.toLowerCase().includes(field)\n          );\n          \n          if (isLocationField) {\n            mapData.push({\n              field_name: input.name,\n              field_value: input.value,\n              field_id: input.id || null,\n              source: 'hidden_input_location',\n              extracted_at: new Date().toISOString()\n            });\n            \n            console.log(`  ‚Ä¢ Location Input: ${input.name} = ${input.value}`);\n          }\n        }\n      });\n    }\n    \n    return mapData;\n  }\n  \n  function extractJavaScriptData(scriptContent) {\n    console.log('üìú Extracting JavaScript variables and data...');\n    const jsData = {\n      scan_guid: null,\n      place_id: null,\n      keyword_id: null,\n      keyword_guid: null,\n      pinz: [],\n      api_endpoints: [],\n      variables: []\n    };\n    \n    if (!scriptContent || scriptContent.length < 10) {\n      console.log('‚ö†Ô∏è No JavaScript content to process');\n      return { variables: [] };\n    }\n    \n    console.log(`üîç Processing ${scriptContent.length} characters of JavaScript...`);\n    \n    // Enhanced variable extraction patterns\n    const variablePatterns = [\n      {\n        name: 'scan_guid',\n        patterns: [\n          /scan_guid[\"']?\\s*[:=]\\s*[\"']([a-f0-9\\-]{10,})[\"']/gi,\n          /value\\s*=\\s*[\"']([a-f0-9\\-]{15,})[\"'][^>]*name[^>]*scan_guid/gi,\n          /name[^>]*scan_guid[^>]*value\\s*=\\s*[\"']([a-f0-9\\-]{10,})[\"']/gi\n        ]\n      },\n      {\n        name: 'place_id',\n        patterns: [\n          /place_id[\"']?\\s*[:=]\\s*[\"']([^\"']{3,30})[\"']/gi,\n          /value\\s*=\\s*[\"']([^\"']{3,30})[\"'][^>]*name[^>]*place_id/gi,\n          /name[^>]*place_id[^>]*value\\s*=\\s*[\"']([^\"']{3,30})[\"']/gi\n        ]\n      },\n      {\n        name: 'keyword_id',\n        patterns: [\n          /keyword_id[\"']?\\s*[:=]\\s*[\"']([^\"']{3,30})[\"']/gi,\n          /value\\s*=\\s*[\"']([^\"']{3,30})[\"'][^>]*name[^>]*keyword_id/gi\n        ]\n      },\n      {\n        name: 'keyword_guid',\n        patterns: [\n          /keyword_guid[\"']?\\s*[:=]\\s*[\"']([a-f0-9\\-]{10,})[\"']/gi,\n          /value\\s*=\\s*[\"']([a-f0-9\\-]{10,})[\"'][^>]*name[^>]*keyword_guid/gi\n        ]\n      }\n    ];\n    \n    // Extract specific variables\n    variablePatterns.forEach(varConfig => {\n      varConfig.patterns.forEach(pattern => {\n        const matches = scriptContent.match(pattern) || [];\n        matches.forEach(match => {\n          const valueMatch = match.match(/[\"']([^\"']+)[\"']/);\n          if (valueMatch && valueMatch[1] && valueMatch[1] !== varConfig.name) {\n            if (!jsData[varConfig.name]) {\n              jsData[varConfig.name] = valueMatch[1];\n              console.log(`‚úÖ Found ${varConfig.name}: ${valueMatch[1]}`);\n            }\n          }\n        });\n      });\n    });\n    \n    // Extract pinz array\n    const pinzPatterns = [\n      /pinz\\s*[:=]\\s*\\[([^\\]]+)\\]/gi,\n      /var\\s+pinz\\s*=\\s*\\[([^\\]]+)\\]/gi\n    ];\n    \n    pinzPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const arrayMatch = match.match(/\\[([^\\]]+)\\]/);\n        if (arrayMatch) {\n          const arrayContent = arrayMatch[1];\n          const items = arrayContent.split(',').map(item => \n            item.trim().replace(/[\"']/g, '')\n          ).filter(item => item.length > 0);\n          \n          if (items.length > 0) {\n            jsData.pinz = items;\n            console.log(`‚úÖ Found pinz array: ${items.length} items`);\n          }\n        }\n      });\n    });\n    \n    // Extract API endpoints\n    const apiPatterns = [\n      /[\"']\\/api\\/[^\"']+[\"']/gi,\n      /[\"']https?:\\/\\/[^\"']*\\/api\\/[^\"']*[\"']/gi,\n      /url\\s*[:=]\\s*[\"']([^\"']*api[^\"']*)[\"']/gi,\n      /endpoint\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi\n    ];\n    \n    const foundEndpoints = new Set();\n    apiPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const urlMatch = match.match(/[\"']([^\"']+)[\"']/);\n        if (urlMatch && urlMatch[1]) {\n          const url = urlMatch[1];\n          if (url.includes('api') || url.includes('data') || url.includes('ajax')) {\n            foundEndpoints.add(url);\n          }\n        }\n      });\n    });\n    \n    jsData.api_endpoints = Array.from(foundEndpoints);\n    if (jsData.api_endpoints.length > 0) {\n      console.log(`‚úÖ Found ${jsData.api_endpoints.length} API endpoints`);\n    }\n    \n    // Extract general variables\n    const generalVarPatterns = [\n      /var\\s+(\\w+)\\s*=\\s*[\"']([^\"']{2,50})[\"']/gi,\n      /let\\s+(\\w+)\\s*=\\s*[\"']([^\"']{2,50})[\"']/gi,\n      /const\\s+(\\w+)\\s*=\\s*[\"']([^\"']{2,50})[\"']/gi\n    ];\n    \n    const foundVars = new Set();\n    generalVarPatterns.forEach(pattern => {\n      let varMatch;\n      while ((varMatch = pattern.exec(scriptContent)) !== null && jsData.variables.length < 30) {\n        const varName = varMatch[1];\n        const varValue = varMatch[2];\n        \n        if (varName && varValue && !foundVars.has(varName) && varValue.length > 2) {\n          foundVars.add(varName);\n          jsData.variables.push({\n            name: varName,\n            value: varValue,\n            type: 'string',\n            extracted_at: new Date().toISOString()\n          });\n          \n          console.log(`üìù Variable: ${varName} = ${varValue}`);\n        }\n      }\n    });\n    \n    console.log(`üîç JavaScript extraction summary:`);\n    console.log(`  ‚Ä¢ scan_guid: ${jsData.scan_guid || 'Not found'}`);\n    console.log(`  ‚Ä¢ place_id: ${jsData.place_id || 'Not found'}`);\n    console.log(`  ‚Ä¢ keyword_id: ${jsData.keyword_id || 'Not found'}`);\n    console.log(`  ‚Ä¢ keyword_guid: ${jsData.keyword_guid || 'Not found'}`);\n    console.log(`  ‚Ä¢ pinz array: ${jsData.pinz.length} items`);\n    console.log(`  ‚Ä¢ API endpoints: ${jsData.api_endpoints.length} endpoints`);\n    console.log(`  ‚Ä¢ Variables: ${jsData.variables.length} variables`);\n    \n    return jsData;\n  }\n  \n  // Initialize results structure\n  if (!session.results) {\n    session.results = {\n      ozet_bilgiler: [],\n      rakipler: [],\n      sponsorlu_listeler: [],\n      detayli_sonuclar: [],\n      harita_verileri: [],\n      javascript_verileri: [],\n      api_verileri: []\n    };\n  }\n  \n  // Apply specialized extraction functions\n  console.log('üîÑ Applying specialized extraction functions...');\n  \n  // 1. Extract summary information\n  const summaryData = extractBusinessSummary(htmlContent);\n  session.results.ozet_bilgiler = summaryData;\n  \n  // 2. Extract competitor information\n  const competitorData = extractCompetitors(htmlContent);\n  session.results.rakipler = competitorData;\n  \n  // 3. Extract sponsored listings\n  const sponsoredData = extractSponsoredListings(htmlContent);\n  session.results.sponsorlu_listeler = sponsoredData;\n  \n  // 4. Extract map data\n  const mapData = extractMapData(htmlContent);\n  session.results.harita_verileri = mapData;\n  \n  // 5. Extract JavaScript data\n  const jsData = extractJavaScriptData(extractedHtml?.all_scripts || '');\n  \n  // Convert JS data to proper format for javascript_verileri\n  const jsResults = [];\n  \n  // Add key variables\n  if (jsData.scan_guid) {\n    jsResults.push({\n      variable: 'scan_guid',\n      value: jsData.scan_guid,\n      data_type: 'identifier',\n      extracted_at: new Date().toISOString()\n    });\n  }\n  \n  if (jsData.place_id) {\n    jsResults.push({\n      variable: 'place_id',\n      value: jsData.place_id,\n      data_type: 'identifier',\n      extracted_at: new Date().toISOString()\n    });\n  }\n  \n  if (jsData.keyword_id) {\n    jsResults.push({\n      variable: 'keyword_id',\n      value: jsData.keyword_id,\n      data_type: 'identifier',\n      extracted_at: new Date().toISOString()\n    });\n  }\n  \n  if (jsData.keyword_guid) {\n    jsResults.push({\n      variable: 'keyword_guid',\n      value: jsData.keyword_guid,\n      data_type: 'identifier',\n      extracted_at: new Date().toISOString()\n    });\n  }\n  \n  // Add pinz array\n  if (jsData.pinz && jsData.pinz.length > 0) {\n    jsData.pinz.forEach((pin, index) => {\n      jsResults.push({\n        variable: `pinz_${index}`,\n        value: pin,\n        data_type: 'array_item',\n        extracted_at: new Date().toISOString()\n      });\n    });\n  }\n  \n  // Add other variables\n  if (jsData.variables) {\n    jsData.variables.forEach(variable => {\n      jsResults.push(variable);\n    });\n  }\n  \n  session.results.javascript_verileri = jsResults;\n  \n  // Store JS data for API scraping\n  session.js_extracted_data = jsData;\n  \n  // 6. Build detailed results from all extracted data\n  const detailedResults = [];\n  \n  // Include all table data as detailed results\n  if (extractedHtml?.all_tables) {\n    extractedHtml.all_tables.forEach((table, index) => {\n      const tableText = table\n        .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n        .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n        .replace(/<[^>]*>/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n      \n      if (tableText.length > 20) {\n        detailedResults.push({\n          type: 'table_data',\n          index: index,\n          content: tableText,\n          length: tableText.length,\n          source: 'html_table_extraction',\n          extracted_at: new Date().toISOString()\n        });\n      }\n    });\n  }\n  \n  // Include business cards as detailed results\n  if (extractedHtml?.business_cards) {\n    extractedHtml.business_cards.forEach((card, index) => {\n      const cardText = card\n        .replace(/<[^>]*>/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n      \n      if (cardText.length > 10) {\n        detailedResults.push({\n          type: 'business_card',\n          index: index,\n          content: cardText,\n          length: cardText.length,\n          source: 'business_card_extraction',\n          extracted_at: new Date().toISOString()\n        });\n      }\n    });\n  }\n  \n  session.results.detayli_sonuclar = detailedResults;\n  \n  // If still no data found, add diagnostic information\n  const categories = ['ozet_bilgiler', 'rakipler', 'sponsorlu_listeler', 'detayli_sonuclar', 'harita_verileri', 'javascript_verileri'];\n  const totalDataFound = categories.reduce((sum, category) => sum + session.results[category].length, 0);\n  \n  if (totalDataFound === 0) {\n    console.log('‚ö†Ô∏è No data extracted - adding diagnostic info...');\n    \n    // Show HTML samples for debugging\n    const htmlSample = htmlContent.substring(0, 1000);\n    const htmlEndSample = htmlContent.substring(Math.max(0, htmlContent.length - 500));\n    \n    categories.forEach(category => {\n      session.results[category].push({\n        message: `No ${category.replace('_', ' ')} found`,\n        debug_info: {\n          html_length: htmlContent.length,\n          html_sample_start: htmlSample,\n          html_sample_end: htmlEndSample,\n          tables_found: extractedHtml?.all_tables?.length || 0,\n          scripts_found: extractedHtml?.all_scripts?.length || 0,\n          hidden_inputs_found: extractedHtml?.hidden_inputs?.length || 0\n        },\n        extraction_timestamp: new Date().toISOString()\n      });\n    });\n  }\n  \n  // Update session metrics\n  const totalExtracted = Object.values(session.results).reduce((sum, arr) => sum + (Array.isArray(arr) ? arr.length : 0), 0);\n  const qualityScore = Math.min(100, totalExtracted * 3);\n  \n  session.steps.data_processing = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics = session.metrics || {};\n  session.metrics.total_extracted = totalExtracted;\n  session.metrics.quality_score = qualityScore;\n  session.metrics.processing_time = Date.now() - stepStart;\n  \n  console.log('‚úÖ Specialized Business Data Processing Complete!');\n  console.log(`üìä Final Data Summary:`);\n  console.log(`  ‚Ä¢ ozet_bilgiler: ${session.results.ozet_bilgiler.length} entries`);\n  console.log(`  ‚Ä¢ rakipler: ${session.results.rakipler.length} entries`);\n  console.log(`  ‚Ä¢ sponsorlu_listeler: ${session.results.sponsorlu_listeler.length} entries`);\n  console.log(`  ‚Ä¢ detayli_sonuclar: ${session.results.detayli_sonuclar.length} entries`);\n  console.log(`  ‚Ä¢ harita_verileri: ${session.results.harita_verileri.length} entries`);\n  console.log(`  ‚Ä¢ javascript_verileri: ${session.results.javascript_verileri.length} entries`);\n  console.log(`üìà Total extracted: ${totalExtracted} items`);\n  console.log(`üìà Quality Score: ${qualityScore}/100`);\n  console.log(`‚ö° Processing time: ${session.metrics.processing_time}ms`);\n  \n  return [{ json: session }];\n  \n} catch (error) {\n  if (!session.errors) session.errors = [];\n  session.errors.push({\n    step: 'data_processing',\n    error: error.message,\n    stack: error.stack,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('‚ùå Data Processing Failed:', error.message);\n  console.error('Stack trace:', error.stack);\n  throw error;\n}"
      },
      "id": "data_processing",
      "name": "Data Processing & Assembly",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced Dynamic API Endpoint Scraping\nconst session = $input.first().json;\nconst stepStart = Date.now();\n\ntry {\n  console.log('üöÄ Starting Enhanced Dynamic API Scraping...');\n  \n  session.steps.api_scraping = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  const jsData = session.js_extracted_data || {};\n  const htmlContent = session.html_content || '';\n  \n  // Initialize API data if not exists\n  if (!session.results.api_verileri) {\n    session.results.api_verileri = [];\n  }\n  \n  console.log('üîç Comprehensive API Endpoint Discovery...');\n  \n  // Enhanced API endpoint discovery from multiple sources\n  function discoverApiEndpoints(content, scriptContent) {\n    const discoveredEndpoints = new Set();\n    const apiData = {\n      endpoints: [],\n      parameters: {},\n      ajax_calls: [],\n      fetch_calls: [],\n      xhr_calls: []\n    };\n    \n    console.log('üì° Searching for API endpoints...');\n    \n    // Pattern 1: Direct API URLs\n    const directApiPatterns = [\n      /[\"'](https?:\\/\\/[^\"']*\\/api\\/[^\"']*)[\"']/gi,\n      /[\"'](\\/api\\/[^\"']*)[\"']/gi,\n      /[\"'](https?:\\/\\/[^\"']*\\/v\\d+\\/[^\"']*)[\"']/gi,\n      /[\"'](\\/v\\d+\\/[^\"']*)[\"']/gi\n    ];\n    \n    directApiPatterns.forEach(pattern => {\n      const matches = (content + scriptContent).match(pattern) || [];\n      matches.forEach(match => {\n        const urlMatch = match.match(/[\"']([^\"']+)[\"']/);\n        if (urlMatch && urlMatch[1]) {\n          const url = urlMatch[1];\n          if (url.length > 5 && (url.includes('api') || url.includes('/v'))) {\n            discoveredEndpoints.add(url);\n            console.log(`  üìç Direct API: ${url}`);\n          }\n        }\n      });\n    });\n    \n    // Pattern 2: AJAX calls\n    const ajaxPatterns = [\n      /\\$\\.ajax\\s*\\([^}]*url\\s*:\\s*[\"']([^\"']+)[\"']/gi,\n      /\\$\\.get\\s*\\(\\s*[\"']([^\"']+)[\"']/gi,\n      /\\$\\.post\\s*\\(\\s*[\"']([^\"']+)[\"']/gi,\n      /ajax\\s*\\([^}]*url[^\"']*[\"']([^\"']+)[\"']/gi\n    ];\n    \n    ajaxPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const urlMatch = match.match(/[\"']([^\"']+)[\"']/);\n        if (urlMatch && urlMatch[1]) {\n          const url = urlMatch[1];\n          discoveredEndpoints.add(url);\n          apiData.ajax_calls.push({\n            url: url,\n            method: match.includes('post') ? 'POST' : 'GET',\n            source: 'ajax_pattern'\n          });\n          console.log(`  üîÑ AJAX: ${url}`);\n        }\n      });\n    });\n    \n    // Pattern 3: Fetch calls\n    const fetchPatterns = [\n      /fetch\\s*\\(\\s*[\"']([^\"']+)[\"']/gi,\n      /fetch\\s*\\(\\s*`([^`]+)`/gi,\n      /await\\s+fetch\\s*\\(\\s*[\"']([^\"']+)[\"']/gi\n    ];\n    \n    fetchPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const urlMatch = match.match(/[\"'`]([^\"'`]+)[\"'`]/);\n        if (urlMatch && urlMatch[1]) {\n          const url = urlMatch[1];\n          discoveredEndpoints.add(url);\n          apiData.fetch_calls.push({\n            url: url,\n            method: 'GET',\n            source: 'fetch_pattern'\n          });\n          console.log(`  üåê Fetch: ${url}`);\n        }\n      });\n    });\n    \n    // Pattern 4: XMLHttpRequest\n    const xhrPatterns = [\n      /xhr\\.open\\s*\\(\\s*[\"']([^\"']+)[\"']\\s*,\\s*[\"']([^\"']+)[\"']/gi,\n      /\\.open\\s*\\(\\s*[\"']([^\"']+)[\"']\\s*,\\s*[\"']([^\"']+)[\"']/gi\n    ];\n    \n    xhrPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const parts = match.match(/[\"']([^\"']+)[\"']/g);\n        if (parts && parts.length >= 2) {\n          const method = parts[0].replace(/[\"']/g, '');\n          const url = parts[1].replace(/[\"']/g, '');\n          discoveredEndpoints.add(url);\n          apiData.xhr_calls.push({\n            url: url,\n            method: method.toUpperCase(),\n            source: 'xhr_pattern'\n          });\n          console.log(`  üîå XHR: ${method} ${url}`);\n        }\n      });\n    });\n    \n    // Pattern 5: Common endpoint patterns\n    const commonPatterns = [\n      /[\"']([^\"']*\\/data[^\"']*)[\"']/gi,\n      /[\"']([^\"']*\\/search[^\"']*)[\"']/gi,\n      /[\"']([^\"']*\\/query[^\"']*)[\"']/gi,\n      /[\"']([^\"']*\\/json[^\"']*)[\"']/gi,\n      /[\"']([^\"']*\\/ajax[^\"']*)[\"']/gi\n    ];\n    \n    commonPatterns.forEach(pattern => {\n      const matches = (content + scriptContent).match(pattern) || [];\n      matches.forEach(match => {\n        const urlMatch = match.match(/[\"']([^\"']+)[\"']/);\n        if (urlMatch && urlMatch[1]) {\n          const url = urlMatch[1];\n          if (url.length > 8 && !url.includes('.css') && !url.includes('.js') && !url.includes('.png')) {\n            discoveredEndpoints.add(url);\n            console.log(`  üìä Data endpoint: ${url}`);\n          }\n        }\n      });\n    });\n    \n    apiData.endpoints = Array.from(discoveredEndpoints);\n    \n    console.log(`üîç Discovery Results:`);\n    console.log(`  ‚Ä¢ Total endpoints: ${apiData.endpoints.length}`);\n    console.log(`  ‚Ä¢ AJAX calls: ${apiData.ajax_calls.length}`);\n    console.log(`  ‚Ä¢ Fetch calls: ${apiData.fetch_calls.length}`);\n    console.log(`  ‚Ä¢ XHR calls: ${apiData.xhr_calls.length}`);\n    \n    return apiData;\n  }\n  \n  // Enhanced parameter extraction\n  function extractApiParameters(jsData, scriptContent) {\n    console.log('üîß Extracting API parameters...');\n    const parameters = {};\n    \n    // Add key identifiers from JS data\n    if (jsData.scan_guid) {\n      parameters.scan_guid = jsData.scan_guid;\n      console.log(`  üîë scan_guid: ${jsData.scan_guid}`);\n    }\n    \n    if (jsData.place_id) {\n      parameters.place_id = jsData.place_id;\n      console.log(`  üîë place_id: ${jsData.place_id}`);\n    }\n    \n    if (jsData.keyword_id) {\n      parameters.keyword_id = jsData.keyword_id;\n      console.log(`  üîë keyword_id: ${jsData.keyword_id}`);\n    }\n    \n    if (jsData.keyword_guid) {\n      parameters.keyword_guid = jsData.keyword_guid;\n      console.log(`  üîë keyword_guid: ${jsData.keyword_guid}`);\n    }\n    \n    // Extract common API parameters from script\n    const paramPatterns = [\n      /[\"']?([a-z_]+_id)[\"']?\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi,\n      /[\"']?([a-z_]+_guid)[\"']?\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi,\n      /[\"']?(token)[\"']?\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi,\n      /[\"']?(key)[\"']?\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi,\n      /[\"']?(session)[\"']?\\s*[:=]\\s*[\"']([^\"']+)[\"']/gi\n    ];\n    \n    paramPatterns.forEach(pattern => {\n      const matches = scriptContent.match(pattern) || [];\n      matches.forEach(match => {\n        const parts = match.match(/([a-z_]+)\\s*[:=]\\s*[\"']([^\"']+)[\"']/i);\n        if (parts && parts.length >= 3) {\n          const paramName = parts[1];\n          const paramValue = parts[2];\n          \n          if (paramValue.length > 2 && paramValue.length < 200 && !parameters[paramName]) {\n            parameters[paramName] = paramValue;\n            console.log(`  üîß ${paramName}: ${paramValue}`);\n          }\n        }\n      });\n    });\n    \n    return parameters;\n  }\n  \n  // Discover API endpoints\n  const apiDiscovery = discoverApiEndpoints(htmlContent, jsData.all_scripts || extractedHtml?.all_scripts || '');\n  \n  // Extract parameters\n  const apiParameters = extractApiParameters(jsData, jsData.all_scripts || extractedHtml?.all_scripts || '');\n  \n  // Process discovered endpoints\n  console.log('‚öôÔ∏è Processing discovered endpoints...');\n  \n  if (apiDiscovery.endpoints.length === 0) {\n    console.log('‚ö†Ô∏è No API endpoints discovered');\n    session.results.api_verileri.push({\n      message: 'No API endpoints discovered',\n      discovery_summary: {\n        html_length: htmlContent.length,\n        script_length: (jsData.all_scripts || '').length,\n        ajax_calls: apiDiscovery.ajax_calls.length,\n        fetch_calls: apiDiscovery.fetch_calls.length,\n        xhr_calls: apiDiscovery.xhr_calls.length,\n        parameters_found: Object.keys(apiParameters).length\n      },\n      available_parameters: apiParameters,\n      timestamp: new Date().toISOString()\n    });\n  } else {\n    // Add discovery summary\n    session.results.api_verileri.push({\n      discovery_type: 'endpoint_summary',\n      total_endpoints: apiDiscovery.endpoints.length,\n      ajax_calls: apiDiscovery.ajax_calls.length,\n      fetch_calls: apiDiscovery.fetch_calls.length,\n      xhr_calls: apiDiscovery.xhr_calls.length,\n      available_parameters: apiParameters,\n      timestamp: new Date().toISOString()\n    });\n    \n    // Process each endpoint\n    apiDiscovery.endpoints.slice(0, 15).forEach((endpoint, index) => {\n      console.log(`üåê Processing endpoint ${index + 1}: ${endpoint}`);\n      \n      // Build full URL\n      let fullUrl = endpoint;\n      if (!endpoint.startsWith('http')) {\n        // Try to determine base URL from session target URL\n        const baseUrl = session.target_url ? new URL(session.target_url).origin : 'https://example.com';\n        fullUrl = baseUrl + (endpoint.startsWith('/') ? endpoint : '/' + endpoint);\n      }\n      \n      // Add parameters to URL\n      const urlParams = new URLSearchParams();\n      Object.entries(apiParameters).forEach(([key, value]) => {\n        if (value && String(value).trim() !== '') {\n          urlParams.append(key, String(value));\n        }\n      });\n      \n      const finalUrl = fullUrl + (fullUrl.includes('?') ? '&' : '?') + urlParams.toString();\n      \n      // Determine method from discovery data\n      let method = 'GET';\n      const ajaxCall = apiDiscovery.ajax_calls.find(call => call.url === endpoint);\n      const xhrCall = apiDiscovery.xhr_calls.find(call => call.url === endpoint);\n      \n      if (ajaxCall) method = ajaxCall.method;\n      else if (xhrCall) method = xhrCall.method;\n      \n      // Add to results\n      session.results.api_verileri.push({\n        endpoint_index: index + 1,\n        original_endpoint: endpoint,\n        full_url: finalUrl,\n        method: method,\n        parameters_used: Object.keys(apiParameters),\n        discovery_source: ajaxCall ? 'ajax' : xhrCall ? 'xhr' : 'pattern_match',\n        ready_for_execution: true,\n        request_config: {\n          method: method,\n          url: finalUrl,\n          headers: {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n            'Accept': 'application/json, text/plain, */*',\n            'Accept-Language': 'en-US,en;q=0.9,tr;q=0.8',\n            'Cache-Control': 'no-cache',\n            'Referer': session.target_url || ''\n          },\n          timeout: 10000\n        },\n        timestamp: new Date().toISOString()\n      });\n      \n      console.log(`  ‚úÖ Configured: ${method} ${finalUrl}`);\n    });\n    \n    // Add remaining endpoints info if too many\n    if (apiDiscovery.endpoints.length > 15) {\n      session.results.api_verileri.push({\n        message: `Additional ${apiDiscovery.endpoints.length - 15} endpoints found but not processed (limit reached)`,\n        remaining_endpoints: apiDiscovery.endpoints.slice(15),\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n  \n  // Store API discovery data for potential external processing\n  session.api_discovery_data = {\n    endpoints: apiDiscovery.endpoints,\n    parameters: apiParameters,\n    ajax_calls: apiDiscovery.ajax_calls,\n    fetch_calls: apiDiscovery.fetch_calls,\n    xhr_calls: apiDiscovery.xhr_calls\n  };\n  \n  // Add JavaScript variables for API construction\n  console.log('üìù Adding JavaScript variables for API usage...');\n  if (jsData.variables && jsData.variables.length > 0) {\n    jsData.variables.forEach(variable => {\n      if (variable.name && variable.value && \n          (variable.name.includes('url') || variable.name.includes('endpoint') || \n           variable.name.includes('api') || variable.name.includes('host'))) {\n        session.results.api_verileri.push({\n          type: 'api_variable',\n          variable_name: variable.name,\n          variable_value: variable.value,\n          usage: 'potential_api_component',\n          timestamp: new Date().toISOString()\n        });\n        \n        console.log(`  üìù API Variable: ${variable.name} = ${variable.value}`);\n      }\n    });\n  }\n  \n  session.steps.api_scraping = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics = session.metrics || {};\n  session.metrics.api_endpoints_discovered = apiDiscovery.endpoints.length;\n  session.metrics.api_parameters_found = Object.keys(apiParameters).length;\n  session.metrics.api_processing_time = Date.now() - stepStart;\n  \n  console.log('‚úÖ Enhanced Dynamic API Scraping Complete!');\n  console.log(`üîó Discovered ${apiDiscovery.endpoints.length} API endpoints`);\n  console.log(`üîß Found ${Object.keys(apiParameters).length} API parameters`);\n  console.log(`üìä Total API data entries: ${session.results.api_verileri.length}`);\n  console.log(`‚ö° Processing time: ${session.metrics.api_processing_time}ms`);\n  \n  return [{ json: session }];\n  \n} catch (error) {\n  if (!session.errors) session.errors = [];\n  session.errors.push({\n    step: 'api_scraping',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('‚ùå Enhanced API Scraping Failed:', error.message);\n  throw error;\n}"
      },
      "id": "api_scraping",
      "name": "Dynamic API Scraping",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "functionCode": "// Excel Multi-Sheet Export Preparation\nconst session = $input.first().json;\nconst stepStart = Date.now();\n\ntry {\n  console.log('üìä Starting Excel Multi-Sheet Export Preparation...');\n  \n  session.steps.excel_export = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  const excelData = {\n    metadata: {\n      session_id: session.session_id,\n      target_url: session.target_url,\n      extraction_timestamp: new Date().toISOString(),\n      total_extracted: session.metrics.total_extracted,\n      quality_score: session.metrics.quality_score,\n      processing_time: session.metrics.processing_time\n    },\n    sheets: {}\n  };\n  \n  // Prepare each sheet data\n  const sheets = [\n    { name: 'ozet_bilgiler', title: '√ñzet Bilgiler' },\n    { name: 'rakipler', title: 'Rakipler' },\n    { name: 'sponsorlu_listeler', title: 'Sponsorlu Listeler' },\n    { name: 'detayli_sonuclar', title: 'Detaylƒ± Sonu√ßlar' },\n    { name: 'harita_verileri', title: 'Harita Verileri' },\n    { name: 'javascript_verileri', title: 'JavaScript Verileri' },\n    { name: 'api_verileri', title: 'API Verileri' }\n  ];\n  \n  sheets.forEach(sheet => {\n    const sheetData = session.results[sheet.name] || [];\n    \n    console.log(`üìã Preparing ${sheet.title} sheet with ${sheetData.length} rows`);\n    \n    // Convert data to CSV format for Excel compatibility\n    const csvRows = [];\n    \n    if (sheetData.length > 0) {\n      // Get all unique keys for headers\n      const allKeys = new Set();\n      sheetData.forEach(row => {\n        Object.keys(row).forEach(key => allKeys.add(key));\n      });\n      \n      const headers = Array.from(allKeys);\n      csvRows.push(headers.join(','));\n      \n      // Add data rows\n      sheetData.forEach(row => {\n        const csvRow = headers.map(header => {\n          const value = row[header] || '';\n          // Escape CSV values\n          const stringValue = typeof value === 'object' ? JSON.stringify(value) : String(value);\n          return `\"${stringValue.replace(/\"/g, '\"\"')}\"`;\n        });\n        csvRows.push(csvRow.join(','));\n      });\n    } else {\n      csvRows.push('message');\n      csvRows.push('\"No data found\"');\n    }\n    \n    excelData.sheets[sheet.name] = {\n      title: sheet.title,\n      csv_data: csvRows.join('\\n'),\n      row_count: sheetData.length,\n      column_count: csvRows.length > 0 ? csvRows[0].split(',').length : 0\n    };\n  });\n  \n  // Store Excel data in session\n  session.excel_export_data = excelData;\n  \n  session.steps.excel_export = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics.excel_export_time = Date.now() - stepStart;\n  \n  console.log('‚úÖ Excel Multi-Sheet Export Preparation Complete!');\n  console.log(`üìä Export Summary:`);\n  Object.entries(excelData.sheets).forEach(([sheetName, sheetInfo]) => {\n    console.log(`  ‚Ä¢ ${sheetInfo.title}: ${sheetInfo.row_count} rows, ${sheetInfo.column_count} columns`);\n  });\n  console.log(`‚ö° Export preparation time: ${session.metrics.excel_export_time}ms`);\n  \n  return [{ json: session }];\n  \n} catch (error) {\n  session.errors.push({\n    step: 'excel_export',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('‚ùå Excel Export Preparation Failed:', error.message);\n  throw error;\n}"
      },
      "id": "excel_export",
      "name": "Excel Multi-Sheet Export",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1600, 300]
    }
  ],
  "connections": {
    "Extraction Configuration": {
      "main": [
        [
          {
            "node": "Session Initialization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Initialization": {
      "main": [
        [
          {
            "node": "Fetch HTML Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch HTML Content": {
      "main": [
        [
          {
            "node": "Content Analysis & Pattern Recognition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Analysis & Pattern Recognition": {
      "main": [
        [
          {
            "node": "HTML Data Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Data Extraction": {
      "main": [
        [
          {
            "node": "Data Processing & Assembly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Processing & Assembly": {
      "main": [
        [
          {
            "node": "Dynamic API Scraping",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic API Scraping": {
      "main": [
        [
          {
            "node": "Excel Multi-Sheet Export",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {},
  "staticData": {},
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-20T16:30:00.000Z",
  "versionId": "v2.0"
}