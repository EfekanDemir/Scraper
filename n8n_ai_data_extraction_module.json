{
  "name": "Advanced Data Extraction Module v2.0",
  "nodes": [
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "target_url",
              "value": "https://www.local-rank.report/scan/97919fde-e478-4081-983f-7e0065b6b5bb"
            },
            {
              "name": "extraction_strategy",
              "value": "comprehensive_multi_layer"
            },
            {
              "name": "output_format",
              "value": "excel_multi_sheet"
            }
          ],
          "number": [
            {
              "name": "confidence_threshold",
              "value": 0.75
            },
            {
              "name": "timeout_seconds",
              "value": 30
            },
            {
              "name": "retry_attempts",
              "value": 3
            }
          ],
          "boolean": [
            {
              "name": "enable_detailed_extraction",
              "value": true
            },
            {
              "name": "enable_js_extraction",
              "value": true
            },
            {
              "name": "enable_validation",
              "value": true
            }
          ]
        }
      },
      "id": "config_node",
      "name": "Extraction Configuration",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "functionCode": "// Initialize extraction session\nconst config = $input.first().json;\nconst sessionId = `extract_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\nconst session = {\n  session_id: sessionId,\n  started_at: new Date().toISOString(),\n  target_url: config.target_url,\n  \n  // Configuration\n  config: {\n    extraction_strategy: config.extraction_strategy,\n    output_format: config.output_format,\n    confidence_threshold: config.confidence_threshold,\n    timeout_seconds: config.timeout_seconds,\n    retry_attempts: config.retry_attempts,\n    enable_detailed_extraction: config.enable_detailed_extraction,\n    enable_js_extraction: config.enable_js_extraction,\n    enable_validation: config.enable_validation\n  },\n  \n  // Results structure matching Python project\n  extracted_data: {\n    ozet_bilgiler: {},\n    rakipler: [],\n    sponsorlu_listeler: [],\n    detayli_sonuclar: [],\n    harita_verileri: [],\n    javascript_verileri: {},\n    api_verileri: {\n      competitors: null,\n      analytics: []\n    }\n  },\n  \n  // Metrics\n  metrics: {\n    processing_time_ms: 0,\n    elements_found: 0,\n    data_quality_score: 0,\n    extraction_accuracy: 0.0,\n    confidence_score: 0.0\n  },\n  \n  // Status tracking\n  steps: {\n    initialization: { status: 'completed', timestamp: new Date().toISOString() },\n    html_fetch: { status: 'pending' },\n    content_analysis: { status: 'pending' },\n    data_extraction: { status: 'pending' },\n    js_extraction: { status: 'pending' },\n    data_assembly: { status: 'pending' },\n    excel_export: { status: 'pending' }\n  },\n  \n  // Error and warning tracking\n  errors: [],\n  warnings: []\n};\n\nconsole.log(`🚀 Data Extraction Session Started: ${sessionId}`);\nconsole.log('📋 Configuration:', JSON.stringify(session.config, null, 2));\n\nreturn [{ json: session }];"
      },
      "id": "session_init",
      "name": "Session Initialization",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [420, 300]
    },
    {
      "parameters": {
        "url": "={{ $json.target_url }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.9,de;q=0.8"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "fullResponse": true,
              "neverError": true
            }
          }
        }
      },
      "id": "http_fetch",
      "name": "Fetch HTML Content",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [620, 300]
    },
    {
      "parameters": {
        "functionCode": "// Advanced HTML Content Analysis and Pattern Recognition\nconst session = $input.first().json;\nconst httpResponse = $input.last().json;\n\nconst stepStart = Date.now();\n\ntry {\n  // Update step status\n  session.steps.html_fetch = { status: 'completed', timestamp: new Date().toISOString() };\n  session.steps.content_analysis = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  // Extract HTML content with error handling\n  let htmlContent = '';\n  if (httpResponse.body) {\n    htmlContent = httpResponse.body;\n  } else if (httpResponse.data) {\n    htmlContent = httpResponse.data;\n  } else if (typeof httpResponse === 'string') {\n    htmlContent = httpResponse;\n  } else {\n    throw new Error('No HTML content found in response');\n  }\n\n  if (!htmlContent || htmlContent.length < 1000) {\n    throw new Error(`Insufficient content for analysis: ${htmlContent.length} characters`);\n  }\n\n  console.log(`📊 HTML Content Size: ${htmlContent.length} characters`);\n\n  // Content Statistics\n  const contentStats = {\n    total_length: htmlContent.length,\n    element_count: (htmlContent.match(/<[^>]+>/g) || []).length,\n    script_count: (htmlContent.match(/<script[^>]*>/gi) || []).length,\n    table_count: (htmlContent.match(/<table[^>]*>/gi) || []).length,\n    form_count: (htmlContent.match(/<form[^>]*>/gi) || []).length,\n    div_count: (htmlContent.match(/<div[^>]*>/gi) || []).length,\n    link_count: (htmlContent.match(/<a[^>]*>/gi) || []).length\n  };\n\n  // Pattern Detection using Regex\n  function detectDataPatterns(html) {\n    const patterns = {\n      tables: [],\n      cards: [],\n      lists: [],\n      business_data: []\n    };\n\n    // Table Pattern Detection\n    const tableRegex = /<table[^>]*class=\"([^\"]*)\"|<table[^>]*id=\"([^\"]*)\"|<table[^>]*>/gi;\n    let tableMatch;\n    let tableIndex = 0;\n    \n    while ((tableMatch = tableRegex.exec(html)) !== null) {\n      const tableStart = tableMatch.index;\n      const tableEndRegex = /<\\/table>/gi;\n      tableEndRegex.lastIndex = tableStart;\n      const tableEndMatch = tableEndRegex.exec(html);\n      \n      if (tableEndMatch) {\n        const tableHtml = html.substring(tableStart, tableEndMatch.index + 8);\n        const rowCount = (tableHtml.match(/<tr[^>]*>/gi) || []).length;\n        const cellCount = (tableHtml.match(/<td[^>]*>|<th[^>]*>/gi) || []).length;\n        \n        patterns.tables.push({\n          index: tableIndex++,\n          start_position: tableStart,\n          html_snippet: tableHtml.substring(0, 200) + '...',\n          row_count: rowCount,\n          cell_count: cellCount,\n          has_header: tableHtml.includes('<th') || tableHtml.includes('<thead'),\n          class_attr: tableMatch[1] || '',\n          id_attr: tableMatch[2] || '',\n          data_density: calculateDataDensity(tableHtml),\n          business_relevance: calculateBusinessRelevance(tableHtml)\n        });\n      }\n    }\n\n    // Card/Panel Pattern Detection\n    const cardPatterns = [\n      /<div[^>]*class=\"[^\"]*card[^\"]*\"/gi,\n      /<div[^>]*class=\"[^\"]*panel[^\"]*\"/gi,\n      /<div[^>]*class=\"[^\"]*box[^\"]*\"/gi,\n      /<section[^>]*class=\"[^\"]*info[^\"]*\"/gi\n    ];\n    \n    cardPatterns.forEach((pattern, patternIndex) => {\n      let cardMatch;\n      let cardIndex = 0;\n      pattern.lastIndex = 0;\n      \n      while ((cardMatch = pattern.exec(html)) !== null) {\n        const cardStart = cardMatch.index;\n        const cardContent = extractBalancedTag(html, cardStart, 'div');\n        \n        if (cardContent && cardContent.length > 50) {\n          patterns.cards.push({\n            index: cardIndex++,\n            pattern_type: patternIndex,\n            start_position: cardStart,\n            content_length: cardContent.length,\n            text_content: cardContent.replace(/<[^>]*>/g, '').substring(0, 200),\n            has_links: cardContent.includes('<a '),\n            has_images: cardContent.includes('<img '),\n            business_relevance: calculateBusinessRelevance(cardContent)\n          });\n        }\n      }\n    });\n\n    return patterns;\n  }\n\n  // Helper function to extract balanced HTML tags\n  function extractBalancedTag(html, startPos, tagName) {\n    const openTag = new RegExp(`<${tagName}[^>]*>`, 'i');\n    const closeTag = new RegExp(`<\\/${tagName}>`, 'gi');\n    let depth = 1;\n    let pos = startPos;\n    \n    const openMatch = html.substring(pos).match(openTag);\n    if (!openMatch) return null;\n    \n    pos += openMatch[0].length;\n    \n    while (depth > 0 && pos < html.length) {\n      const nextOpen = html.substring(pos).search(openTag);\n      const nextClose = html.substring(pos).search(closeTag);\n      \n      if (nextClose === -1) break;\n      \n      if (nextOpen !== -1 && nextOpen < nextClose) {\n        depth++;\n        pos += nextOpen + html.substring(pos + nextOpen).match(openTag)[0].length;\n      } else {\n        depth--;\n        pos += nextClose + html.substring(pos + nextClose).match(closeTag)[0].length;\n      }\n    }\n    \n    return depth === 0 ? html.substring(startPos, pos) : null;\n  }\n\n  // Calculate data density score (0-100)\n  function calculateDataDensity(content) {\n    if (!content) return 0;\n    \n    let score = 0;\n    const textContent = content.replace(/<[^>]*>/g, '');\n    \n    // Length factor\n    if (textContent.length > 50) score += 20;\n    if (textContent.length > 200) score += 10;\n    \n    // Structured data indicators\n    if (/\\d+/.test(textContent)) score += 15; // Numbers\n    if (/[A-Z][a-z]+ [A-Z][a-z]+/.test(textContent)) score += 10; // Proper names\n    if (/@|\\.|com|org/.test(textContent)) score += 10; // Web indicators\n    if (/\\$|€|£|\\d+\\.\\d{2}/.test(textContent)) score += 10; // Currency\n    if (/\\(\\d{3}\\)|\\d{3}-\\d{3}-\\d{4}/.test(textContent)) score += 15; // Phone\n    \n    // Structure indicators\n    if (content.includes('<td') || content.includes('<th')) score += 10;\n    if (content.includes('<li')) score += 5;\n    \n    return Math.min(100, score);\n  }\n\n  // Calculate business relevance score (0-100)\n  function calculateBusinessRelevance(content) {\n    if (!content) return 0;\n    \n    const textLower = content.toLowerCase();\n    let score = 0;\n    \n    // Business keywords\n    const businessKeywords = [\n      'business', 'company', 'name', 'address', 'phone', 'website',\n      'rank', 'position', 'competitor', 'ranking', 'score', 'scan',\n      'report', 'analysis', 'summary'\n    ];\n    \n    businessKeywords.forEach(keyword => {\n      if (textLower.includes(keyword)) {\n        score += 5;\n      }\n    });\n    \n    return Math.min(100, score);\n  }\n\n  // Execute Pattern Detection\n  const detectedPatterns = detectDataPatterns(htmlContent);\n\n  // Generate Extraction Strategies\n  const extractionStrategies = [];\n\n  // Table extraction strategies\n  detectedPatterns.tables.forEach(table => {\n    if (table.business_relevance > 15 && table.data_density > 30) {\n      extractionStrategies.push({\n        type: 'table_extraction',\n        priority: table.business_relevance + table.data_density,\n        selector: table.class_attr ? `.${table.class_attr}` : (table.id_attr ? `#${table.id_attr}` : `table:nth-of-type(${table.index + 1})`),\n        confidence: Math.min(0.95, (table.business_relevance + table.data_density) / 100),\n        expected_data: table.has_header ? 'structured_business_data' : 'tabular_data',\n        row_count: table.row_count\n      });\n    }\n  });\n\n  // Card extraction strategies\n  detectedPatterns.cards.forEach(card => {\n    if (card.business_relevance > 10) {\n      extractionStrategies.push({\n        type: 'card_extraction',\n        priority: card.business_relevance,\n        selector: `div:nth-of-type(${card.index + 1})`,\n        confidence: Math.min(0.90, card.business_relevance / 50),\n        expected_data: 'business_card_info',\n        content_length: card.content_length\n      });\n    }\n  });\n\n  // Sort strategies by priority\n  extractionStrategies.sort((a, b) => b.priority - a.priority);\n\n  // Update session with analysis results\n  session.html_content = htmlContent;\n  session.content_stats = contentStats;\n  session.detected_patterns = detectedPatterns;\n  session.extraction_strategies = extractionStrategies;\n  session.steps.content_analysis = { status: 'completed', timestamp: new Date().toISOString() };\n  session.metrics.processing_time = Date.now() - stepStart;\n\n  console.log('✅ Content Analysis Complete');\n  console.log(`📊 Found ${extractionStrategies.length} extraction strategies`);\n  console.log(`🎯 Top strategy confidence: ${extractionStrategies[0]?.confidence || 0}`);\n  console.log(`⚡ Processing time: ${session.metrics.processing_time}ms`);\n\n  return [{ json: session }];\n\n} catch (error) {\n  session.errors = session.errors || [];\n  session.errors.push({\n    step: 'content_analysis',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('❌ Content Analysis Failed:', error.message);\n  throw error;\n}"
      },
      "id": "content_analysis",
      "name": "Content Analysis & Pattern Recognition",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [820, 300]
    },
    {
      "parameters": {
        "functionCode": "// HTML Data Extraction using CSS selectors and regex\nconst session = $input.first().json;\n\nconst stepStart = Date.now();\n\ntry {\n  session.steps.data_extraction = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  const htmlContent = session.html_content;\n  const extractedData = {\n    scan_info_table: '',\n    rank_summary_table: '',\n    competitors_table: '',\n    sponsored_listings: '',\n    all_tables: '',\n    all_scripts: ''\n  };\n\n  // Extract all tables\n  const tableMatches = htmlContent.match(/<table[^>]*>.*?<\\/table>/gis) || [];\n  extractedData.all_tables = tableMatches.join('\\n');\n  \n  // Extract specific tables by context\n  tableMatches.forEach((tableHtml, index) => {\n    const tableText = tableHtml.replace(/<[^>]*>/g, '').toLowerCase();\n    \n    if (tableText.includes('scan') || tableText.includes('business') || tableText.includes('information')) {\n      extractedData.scan_info_table = tableHtml;\n    } else if (tableText.includes('rank') || tableText.includes('position') || tableText.includes('summary')) {\n      extractedData.rank_summary_table = tableHtml;\n    } else if (tableText.includes('competitor') || tableText.includes('company') || index === 0) {\n      extractedData.competitors_table = tableHtml;\n    }\n  });\n  \n  // Extract sponsored listings\n  const sponsoredRegex = /<[^>]*class=\"[^\"]*sponsor[^\"]*\"[^>]*>.*?<\\/[^>]*>/gis;\n  const sponsoredMatches = htmlContent.match(sponsoredRegex) || [];\n  extractedData.sponsored_listings = sponsoredMatches.join('\\n');\n  \n  // Extract all script tags\n  const scriptMatches = htmlContent.match(/<script[^>]*>.*?<\\/script>/gis) || [];\n  extractedData.all_scripts = scriptMatches.join('\\n');\n  \n  session.steps.data_extraction = { status: 'completed', timestamp: new Date().toISOString() };\n  \n  console.log('✅ HTML Data Extraction Complete');\n  console.log(`📊 Extracted ${tableMatches.length} tables`);\n  console.log(`📜 Extracted ${scriptMatches.length} scripts`);\n  \n  return [{ json: { session, extracted_html: extractedData } }];\n  \n} catch (error) {\n  session.errors = session.errors || [];\n  session.errors.push({\n    step: 'data_extraction',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('❌ HTML Data Extraction Failed:', error.message);\n  throw error;\n}"
      },
      "id": "html_extraction",
      "name": "HTML Data Extraction",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1020, 300]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced Data Processing & Final Assembly for Excel Export\nconst inputData = $input.first().json;\nconst session = inputData.session;\nconst extractedHtml = inputData.extracted_html;\n\nconst stepStart = Date.now();\n\ntry {\n  console.log('🔄 Starting Enhanced Data Processing...');\n  \n  session.steps.data_assembly = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  // Initialize final data structure matching Python project\n  const finalData = {\n    ozet_bilgiler: {},        // Sheet 1: Summary information\n    rakipler: [],             // Sheet 2: Competitors\n    sponsorlu_listeler: [],   // Sheet 3: Sponsored listings\n    detayli_sonuclar: [],     // Sheet 4: Detailed results\n    harita_verileri: [],      // Sheet 5: Map data\n    javascript_verileri: {},  // Sheet 6: JavaScript data\n    api_verileri: {           // Sheet 7: API data\n      competitors: null,\n      analytics: []\n    },\n    metadata: {\n      session_id: session.session_id,\n      scraped_at: new Date().toISOString(),\n      source_url: session.target_url,\n      scraper_version: 'n8n-advanced-v2.0',\n      method: 'n8n_comprehensive_extraction',\n      processing_time_ms: 0,\n      data_quality_score: 0\n    }\n  };\n  \n  // Advanced Table Processing Function\n  function processTableData(tableHtml, tableType) {\n    if (!tableHtml || typeof tableHtml !== 'string') return [];\n    \n    const rows = [];\n    const tableRows = tableHtml.match(/<tr[^>]*>.*?<\\/tr>/gi) || [];\n    \n    tableRows.forEach((rowHtml, index) => {\n      const cells = rowHtml.match(/<t[hd][^>]*>.*?<\\/t[hd]>/gi) || [];\n      \n      if (cells.length >= 2) {\n        const rowData = {};\n        \n        cells.forEach((cellHtml, cellIndex) => {\n          const cellText = cellHtml.replace(/<[^>]*>/g, '').trim();\n          \n          if (cellText) {\n            // Smart column naming\n            let columnName = `column_${cellIndex}`;\n            \n            if (cellIndex === 0 && (cellText.includes('#') || /^\\d+$/.test(cellText))) {\n              columnName = 'rank';\n            } else if (cellText.toLowerCase().includes('business') || cellText.toLowerCase().includes('name')) {\n              columnName = 'business_name';\n            } else if (cellText.toLowerCase().includes('address') || cellText.toLowerCase().includes('location')) {\n              columnName = 'address';\n            } else if (cellText.toLowerCase().includes('phone') || /\\(?\\d{3}\\)?[-.]?\\d{3}[-.]?\\d{4}/.test(cellText)) {\n              columnName = 'phone';\n            } else if (cellText.toLowerCase().includes('website') || cellText.includes('www.') || cellText.includes('http')) {\n              columnName = 'website';\n            }\n            \n            // Enhanced data type detection\n            let processedValue = cellText;\n            \n            // Phone number detection\n            const phoneMatch = cellText.match(/\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})/);\n            if (phoneMatch) {\n              processedValue = phoneMatch[0];\n              columnName = 'phone';\n            }\n            \n            // Email detection\n            const emailMatch = cellText.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/);\n            if (emailMatch) {\n              processedValue = emailMatch[0];\n              columnName = 'email';\n            }\n            \n            // Ranking position detection\n            if (/^#?\\d+$/.test(cellText)) {\n              processedValue = parseInt(cellText.replace('#', ''));\n              if (columnName.includes('column_0') || index === 0) {\n                columnName = 'rank';\n              }\n            }\n            \n            rowData[columnName] = processedValue;\n          }\n        });\n        \n        if (Object.keys(rowData).length > 0) {\n          rows.push({\n            index: index,\n            data: rowData,\n            row_type: index === 0 ? 'header' : 'data',\n            confidence: calculateRowConfidence(rowData)\n          });\n        }\n      }\n    });\n    \n    return rows;\n  }\n  \n  // Calculate confidence score for extracted row data\n  function calculateRowConfidence(rowData) {\n    let confidence = 0.5; // Base confidence\n    \n    Object.values(rowData).forEach(value => {\n      if (typeof value === 'string' && value.length > 3) {\n        confidence += 0.1;\n        \n        // Bonus for structured data\n        if (value.includes('@')) confidence += 0.1; // Email\n        if (/\\d{3}/.test(value)) confidence += 0.1; // Phone or ID\n        if (value.includes('www.') || value.includes('http')) confidence += 0.1; // URL\n      }\n      \n      if (typeof value === 'number') {\n        confidence += 0.15;\n      }\n    });\n    \n    return Math.min(1.0, confidence);\n  }\n  \n  // Process extracted HTML data\n  if (extractedHtml.scan_info_table) {\n    const scanRows = processTableData(extractedHtml.scan_info_table, 'scan_info');\n    \n    scanRows.forEach(row => {\n      if (row.row_type === 'data' && row.confidence > 0.6) {\n        Object.assign(finalData.ozet_bilgiler, row.data);\n      }\n    });\n  }\n  \n  if (extractedHtml.rank_summary_table) {\n    const rankRows = processTableData(extractedHtml.rank_summary_table, 'rank_summary');\n    \n    rankRows.forEach(row => {\n      if (row.row_type === 'data' && row.confidence > 0.6) {\n        Object.assign(finalData.ozet_bilgiler, row.data);\n      }\n    });\n  }\n  \n  if (extractedHtml.competitors_table) {\n    const competitorRows = processTableData(extractedHtml.competitors_table, 'competitors');\n    \n    competitorRows.forEach(row => {\n      if (row.row_type === 'data' && row.confidence > 0.6) {\n        finalData.rakipler.push({\n          rank: row.data.rank || row.index,\n          business_name: row.data.business_name || row.data.column_1 || 'Unknown',\n          address: row.data.address || row.data.column_2 || '',\n          phone: row.data.phone || '',\n          website: row.data.website || '',\n          confidence: row.confidence\n        });\n      }\n    });\n  }\n  \n  // Process all tables as fallback\n  if (extractedHtml.all_tables && Object.keys(finalData.ozet_bilgiler).length === 0) {\n    const allRows = processTableData(extractedHtml.all_tables, 'general');\n    \n    // Smart categorization of data\n    allRows.forEach(row => {\n      if (row.confidence > 0.7) {\n        const rowText = JSON.stringify(row.data).toLowerCase();\n        \n        if (rowText.includes('business') || rowText.includes('scan') || rowText.includes('name')) {\n          Object.assign(finalData.ozet_bilgiler, row.data);\n        } else if (rowText.includes('rank') || rowText.includes('position') || rowText.includes('summary')) {\n          Object.assign(finalData.ozet_bilgiler, row.data);\n        } else if (rowText.includes('competitor') || rowText.includes('company')) {\n          finalData.rakipler.push({\n            rank: row.data.rank || row.index,\n            business_name: row.data.business_name || Object.values(row.data)[0] || 'Unknown',\n            additional_data: row.data,\n            confidence: row.confidence\n          });\n        }\n      }\n    });\n  }\n  \n  // JavaScript Data Extraction\n  if (extractedHtml.all_scripts) {\n    const jsData = extractJavaScriptData(extractedHtml.all_scripts);\n    finalData.javascript_verileri = jsData;\n    \n    // Convert pinz data to map data\n    if (jsData.pinz && Array.isArray(jsData.pinz)) {\n      finalData.harita_verileri = jsData.pinz.map((pin, index) => ({\n        index: index + 1,\n        lat: pin.lat || pin[0] || null,\n        lng: pin.lng || pin[1] || null,\n        title: pin.title || pin.name || `Location ${index + 1}`,\n        type: pin.type || 'pin',\n        data: pin\n      }));\n    }\n  }\n  \n  function extractJavaScriptData(scriptsHtml) {\n    const jsData = {\n      pinz: [],\n      scan_guid: null,\n      place_id: null,\n      api_endpoints: [],\n      config_data: {}\n    };\n    \n    if (!scriptsHtml || typeof scriptsHtml !== 'string') return jsData;\n    \n    try {\n      // Extract script content\n      const scriptMatches = scriptsHtml.match(/<script[^>]*>(.*?)<\\/script>/gis) || [];\n      \n      scriptMatches.forEach(scriptMatch => {\n        const scriptContent = scriptMatch.replace(/<script[^>]*>|<\\/script>/gi, '');\n        \n        // Extract pinz array\n        const pinzMatches = scriptContent.match(/var\\s+pinz\\s*=\\s*(\\[.*?\\]);|pinz\\s*=\\s*(\\[.*?\\]);/gs);\n        if (pinzMatches) {\n          pinzMatches.forEach(match => {\n            try {\n              const arrayMatch = match.match(/\\[.*?\\]/s);\n              if (arrayMatch) {\n                const pinzArray = JSON.parse(arrayMatch[0]);\n                if (Array.isArray(pinzArray)) {\n                  jsData.pinz = pinzArray;\n                }\n              }\n            } catch (e) {\n              console.warn('Failed to parse pinz array:', e.message);\n            }\n          });\n        }\n        \n        // Extract scan_guid\n        const guidMatches = scriptContent.match(/scan_guid['\"]?\\s*[:=]\\s*['\"]([^'\"]+)['\"]/gi);\n        if (guidMatches && guidMatches[0]) {\n          const guidMatch = guidMatches[0].match(/['\"]([^'\"]+)['\"]/); \n          if (guidMatch) {\n            jsData.scan_guid = guidMatch[1];\n          }\n        }\n        \n        // Extract place_id\n        const placeIdMatches = scriptContent.match(/place_id['\"]?\\s*[:=]\\s*['\"]([^'\"]+)['\"]/gi);\n        if (placeIdMatches && placeIdMatches[0]) {\n          const placeMatch = placeIdMatches[0].match(/['\"]([^'\"]+)['\"]/); \n          if (placeMatch) {\n            jsData.place_id = placeMatch[1];\n          }\n        }\n        \n        // Extract API endpoints\n        const apiMatches = scriptContent.match(/['\"]([^'\"]*\\/api\\/[^'\"]*)['\"]|['\"]([^'\"]*\\/analytics\\/[^'\"]*)['\"]|['\"]([^'\"]*\\/competitors[^'\"]*)['\"]|['\"]([^'\"]*\\/scans\\/[^'\"]*)['\"]|['\"]([^'\"]*\\/data[^'\"]*)['\"]|['\"]([^'\"]*\\/search[^'\"]*)['\"]'/gi);\n        if (apiMatches) {\n          apiMatches.forEach(match => {\n            const url = match.replace(/['\"]([^'\"]*)['\"]/,  '$1');\n            if (url && url.length > 5 && !jsData.api_endpoints.includes(url)) {\n              jsData.api_endpoints.push(url);\n            }\n          });\n        }\n      });\n    } catch (e) {\n      console.warn('JavaScript extraction failed:', e.message);\n    }\n    \n    return jsData;\n  }\n  \n  // Calculate overall data quality score\n  let qualityScore = 0;\n  \n  // Özet bilgiler score (0-30)\n  const ozet_count = Object.keys(finalData.ozet_bilgiler).length;\n  qualityScore += Math.min(30, ozet_count * 6);\n  \n  // Rakipler score (0-30)\n  const rakipler_count = finalData.rakipler.length;\n  qualityScore += Math.min(30, rakipler_count * 3);\n  \n  // JavaScript data score (0-20)\n  if (finalData.javascript_verileri.scan_guid) qualityScore += 10;\n  if (finalData.javascript_verileri.pinz && finalData.javascript_verileri.pinz.length > 0) qualityScore += 10;\n  \n  // Map data score (0-20)\n  if (finalData.harita_verileri.length > 0) qualityScore += 20;\n  \n  finalData.metadata.data_quality_score = Math.round(qualityScore);\n  finalData.metadata.processing_time_ms = Date.now() - stepStart;\n  \n  // Update session with final results\n  session.extracted_data = finalData;\n  session.metrics.data_quality_score = finalData.metadata.data_quality_score;\n  session.metrics.extraction_accuracy = Math.min(100, qualityScore * 1.2);\n  session.steps.data_assembly = { status: 'completed', timestamp: new Date().toISOString() };\n  \n  console.log('🎉 Data Processing Complete!');\n  console.log(`📊 Data Quality Score: ${finalData.metadata.data_quality_score}/100`);\n  console.log(`🎯 Extraction Accuracy: ${session.metrics.extraction_accuracy.toFixed(1)}%`);\n  console.log(`⚡ Total Processing Time: ${finalData.metadata.processing_time_ms}ms`);\n  \n  console.log('\\n📋 Extracted Data Summary:');\n  console.log(`• Özet Bilgiler: ${Object.keys(finalData.ozet_bilgiler).length} fields`);\n  console.log(`• Rakipler: ${finalData.rakipler.length} entries`);\n  console.log(`• Sponsorlu Listeler: ${finalData.sponsorlu_listeler.length} entries`);\n  console.log(`• Detaylı Sonuçlar: ${finalData.detayli_sonuclar.length} entries`);\n  console.log(`• Harita Verileri: ${finalData.harita_verileri.length} locations`);\n  console.log(`• JavaScript Verileri: ${Object.keys(finalData.javascript_verileri).length} fields`);\n  \n  return [{ json: { ...session, final_output: finalData } }];\n  \n} catch (error) {\n  session.errors = session.errors || [];\n  session.errors.push({\n    step: 'data_processing',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('❌ Data Processing Failed:', error.message);\n  throw error;\n}"
      },
      "id": "data_processing",
      "name": "Data Processing & Assembly",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1220, 300]
    },
    {
      "parameters": {
        "functionCode": "// Create Excel file with multiple sheets matching Python project structure\nconst session = $input.first().json;\nconst finalData = session.final_output;\n\ntry {\n  session.steps.excel_export = { status: 'in_progress', timestamp: new Date().toISOString() };\n  \n  // Create Excel-compatible data structure\n  const excelData = {\n    // Sheet 1: Özet Bilgiler (Summary Information)\n    ozet_bilgiler: finalData.ozet_bilgiler && Object.keys(finalData.ozet_bilgiler).length > 0 ? \n      [finalData.ozet_bilgiler] : \n      [{ message: 'No summary information found' }],\n    \n    // Sheet 2: Rakipler (Competitors)\n    rakipler: finalData.rakipler.length > 0 ? \n      finalData.rakipler : \n      [{ message: 'No competitors found' }],\n    \n    // Sheet 3: Sponsorlu Listeler (Sponsored Listings)\n    sponsorlu_listeler: finalData.sponsorlu_listeler.length > 0 ? \n      finalData.sponsorlu_listeler : \n      [{ message: 'No sponsored listings found' }],\n    \n    // Sheet 4: Detaylı Sonuçlar (Detailed Results)\n    detayli_sonuclar: finalData.detayli_sonuclar.length > 0 ? \n      finalData.detayli_sonuclar : \n      [{ message: 'No detailed results found' }],\n    \n    // Sheet 5: Harita Verileri (Map Data)\n    harita_verileri: finalData.harita_verileri.length > 0 ? \n      finalData.harita_verileri : \n      [{ message: 'No map data found' }],\n    \n    // Sheet 6: JavaScript Verileri (JavaScript Data)\n    javascript_verileri: finalData.javascript_verileri && Object.keys(finalData.javascript_verileri).length > 0 ? \n      [finalData.javascript_verileri] : \n      [{ message: 'No JavaScript data found' }],\n    \n    // Sheet 7: API Verileri (API Data)\n    api_verileri: finalData.api_verileri && (finalData.api_verileri.competitors || finalData.api_verileri.analytics.length > 0) ? \n      [finalData.api_verileri] : \n      [{ message: 'No API data found' }],\n    \n    // Metadata sheet\n    metadata: [finalData.metadata]\n  };\n  \n  // Create CSV content for each sheet (Excel compatibility)\n  const csvData = {};\n  \n  Object.keys(excelData).forEach(sheetName => {\n    const sheetData = excelData[sheetName];\n    let csvContent = '';\n    \n    if (sheetData.length > 0) {\n      // Get all possible columns\n      const allColumns = new Set();\n      sheetData.forEach(row => {\n        Object.keys(row).forEach(col => allColumns.add(col));\n      });\n      \n      const columns = Array.from(allColumns);\n      \n      // Header row\n      csvContent += columns.map(col => `\"${col}\"`).join(',') + '\\n';\n      \n      // Data rows\n      sheetData.forEach(row => {\n        const values = columns.map(col => {\n          const value = row[col] || '';\n          if (typeof value === 'object') {\n            return `\"${JSON.stringify(value).replace(/\"/g, '\"\"')}\"`;\n          }\n          return `\"${String(value).replace(/\"/g, '\"\"')}\"`;\n        });\n        csvContent += values.join(',') + '\\n';\n      });\n    }\n    \n    csvData[sheetName] = csvContent;\n  });\n  \n  session.steps.excel_export = { status: 'completed', timestamp: new Date().toISOString() };\n  \n  console.log('✅ Excel Export Data Prepared');\n  console.log(`📊 Created ${Object.keys(excelData).length} sheets`);\n  console.log('📋 Sheets:', Object.keys(excelData).join(', '));\n  \n  return [{ \n    json: { \n      ...session, \n      excel_data: excelData,\n      csv_data: csvData,\n      export_summary: {\n        total_sheets: Object.keys(excelData).length,\n        sheet_names: Object.keys(excelData),\n        data_quality_score: finalData.metadata.data_quality_score,\n        total_records: {\n          ozet_bilgiler: Object.keys(finalData.ozet_bilgiler).length,\n          rakipler: finalData.rakipler.length,\n          sponsorlu_listeler: finalData.sponsorlu_listeler.length,\n          detayli_sonuclar: finalData.detayli_sonuclar.length,\n          harita_verileri: finalData.harita_verileri.length,\n          javascript_verileri: Object.keys(finalData.javascript_verileri).length,\n          api_verileri: finalData.api_verileri.analytics ? finalData.api_verileri.analytics.length : 0\n        }\n      }\n    } \n  }];\n  \n} catch (error) {\n  session.errors = session.errors || [];\n  session.errors.push({\n    step: 'excel_export',\n    error: error.message,\n    timestamp: new Date().toISOString()\n  });\n  \n  console.error('❌ Excel Export Failed:', error.message);\n  throw error;\n}"
      },
      "id": "excel_export",
      "name": "Excel Multi-Sheet Export",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1420, 300]
    }
  ],
  "connections": {
    "Extraction Configuration": {
      "main": [
        [
          {
            "node": "Session Initialization",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Session Initialization": {
      "main": [
        [
          {
            "node": "Fetch HTML Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch HTML Content": {
      "main": [
        [
          {
            "node": "Content Analysis & Pattern Recognition",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Content Analysis & Pattern Recognition": {
      "main": [
        [
          {
            "node": "HTML Data Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Data Extraction": {
      "main": [
        [
          {
            "node": "Data Processing & Assembly",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Data Processing & Assembly": {
      "main": [
        [
          {
            "node": "Excel Multi-Sheet Export",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": ["data-extraction", "html-parsing", "excel-export"],
  "triggerCount": 0,
  "updatedAt": "2024-01-20T15:00:00.000Z",
  "versionId": "2.0"
}