{
  "name": "Local Rank Scraper - Full Featured Version",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "local-rank-full",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 400]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ $json.scan_url || 'https://www.local-rank.report/scan/default-scan-id' }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7"
            },
            {
              "name": "Accept-Language",
              "value": "en-US,en;q=0.9,tr;q=0.8"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br"
            },
            {
              "name": "Cache-Control",
              "value": "no-cache"
            },
            {
              "name": "Pragma",
              "value": "no-cache"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Upgrade-Insecure-Requests",
              "value": "1"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "document"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "navigate"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "none"
            },
            {
              "name": "Sec-Fetch-User",
              "value": "?1"
            }
          ]
        },
        "options": {
          "timeout": 45000,
          "followRedirect": true,
          "ignoreResponseCode": false,
          "response": {
            "responseFormat": "string"
          }
        }
      },
      "id": "fetch-html-primary",
      "name": "Fetch HTML - Primary",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [300, 400]
    },
    {
      "parameters": {
        "command": "timeout 30 python3 -c \"\\nfrom selenium import webdriver\\nfrom selenium.webdriver.chrome.options import Options\\nfrom selenium.webdriver.common.by import By\\nfrom selenium.webdriver.support.ui import WebDriverWait\\nfrom selenium.webdriver.support import expected_conditions as EC\\nimport sys\\n\\nurl = sys.argv[1] if len(sys.argv) > 1 else 'about:blank'\\n\\noptions = Options()\\noptions.add_argument('--headless')\\noptions.add_argument('--no-sandbox')\\noptions.add_argument('--disable-dev-shm-usage')\\noptions.add_argument('--disable-gpu')\\noptions.add_argument('--window-size=1920,1080')\\noptions.add_argument('--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')\\n\\ntry:\\n    driver = webdriver.Chrome(options=options)\\n    driver.get(url)\\n    WebDriverWait(driver, 10).until(EC.presence_of_element_located((By.TAG_NAME, 'body')))\\n    print(driver.page_source)\\nfinally:\\n    if 'driver' in locals():\\n        driver.quit()\\n\" '{{ $json.scan_url || \"about:blank\" }}'",
        "options": {}
      },
      "id": "selenium-fallback",
      "name": "Selenium Fallback",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [300, 550]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-1",
              "leftValue": "={{ $json.statusCode }}",
              "rightValue": 200,
              "operator": {
                "type": "number",
                "operation": "equals",
                "rightType": "number"
              }
            },
            {
              "id": "condition-2",
              "leftValue": "={{ $json.data ? $json.data.length : 0 }}",
              "rightValue": 1000,
              "operator": {
                "type": "number",
                "operation": "gt",
                "rightType": "number"
              }
            }
          ],
          "combineOperation": "all"
        },
        "options": {}
      },
      "id": "check-html-quality",
      "name": "Check HTML Quality",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [500, 400]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-html-sources",
      "name": "Merge HTML Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [700, 475]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced JavaScript Data Extraction - Full Version\\n// Equivalent to js_extractor.py module\\n\\nconst htmlContent = $input.first().json.data || $input.first().json.output || '';\\n\\nif (!htmlContent || typeof htmlContent !== 'string') {\\n  return { \\n    error: 'No HTML content received',\\n    javascript_data: {\\n      pinz_array: [],\\n      scan_guid: '',\\n      place_id: '',\\n      pinz_count: 0\\n    }\\n  };\\n}\\n\\n// Safe JSON parsing with multiple fallbacks\\nfunction safeJsonLoads(text) {\\n  if (!text) return [];\\n  \\n  try {\\n    return JSON.parse(text);\\n  } catch (e) {\\n    try {\\n      // JavaScript boolean/null values to Python equivalents\\n      let cleanText = text\\n        .replace(/\\\\btrue\\\\b/gi, 'true')\\n        .replace(/\\\\bfalse\\\\b/gi, 'false')\\n        .replace(/\\\\bnull\\\\b/gi, 'null')\\n        .replace(/\\\\bundefined\\\\b/gi, 'null')\\n        .replace(/,\\\\s*}/g, '}')\\n        .replace(/,\\\\s*]/g, ']')\\n        .replace(/([{,]\\\\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\\\\s*:/g, '$1\"$2\":'); // Quote unquoted keys\\n      \\n      return JSON.parse(cleanText);\\n    } catch (e2) {\\n      console.log('JSON parse error:', e2.message);\\n      return [];\\n    }\\n  }\\n}\\n\\n// Extract pinz data with multiple patterns (equivalent to extract_pinz_data)\\nfunction extractPinzData(html) {\\n  const patterns = [\\n    /var\\\\s+pinz\\\\s*=\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\]);/i,\\n    /window\\\\.pinz\\\\s*=\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\]);/i,\\n    /pinz\\\\s*:\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\])/i,\\n    /['\\\"]pinz['\\\"]\\\\s*:\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\])/i,\\n    /let\\\\s+pinz\\\\s*=\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\]);/i,\\n    /const\\\\s+pinz\\\\s*=\\\\s*(\\\\[[\\\\s\\\\S]*?\\\\]);/i\\n  ];\\n  \\n  for (const pattern of patterns) {\\n    const match = html.match(pattern);\\n    if (match && match[1]) {\\n      const pinzData = safeJsonLoads(match[1]);\\n      if (Array.isArray(pinzData) && pinzData.length > 0) {\\n        console.log(`Found pinz data with pattern ${patterns.indexOf(pattern) + 1}: ${pinzData.length} items`);\\n        return pinzData;\\n      }\\n    }\\n  }\\n  \\n  console.log('No pinz data found');\\n  return [];\\n}\\n\\n// Extract scan_guid with multiple patterns (equivalent to extract_scan_guid)\\nfunction extractScanGuid(html) {\\n  const patterns = [\\n    /scan_guid[\\\"\\']?\\\\s*[:=]\\\\s*[\\\"\\']([a-f0-9-]{8,})[\\\"\\']?/i,\\n    /scan[_-]?guid[\\\"\\']?\\\\s*[:=]\\\\s*[\\\"\\']([a-f0-9-]{8,})[\\\"\\']?/i,\\n    /[\\\"\\']scan_guid[\\\"\\']\\\\s*:\\\\s*[\\\"\\']([a-f0-9-]{8,})[\\\"\\']?/i,\\n    /data-scan-guid\\\\s*=\\\\s*[\\\"\\']([a-f0-9-]{8,})[\\\"\\']?/i,\\n    /window\\\\.scan_guid\\\\s*=\\\\s*[\\\"\\']([a-f0-9-]{8,})[\\\"\\']?/i\\n  ];\\n  \\n  for (const pattern of patterns) {\\n    const match = html.match(pattern);\\n    if (match && match[1] && match[1].length >= 8) {\\n      console.log(`Found scan_guid: ${match[1]}`);\\n      return match[1];\\n    }\\n  }\\n  \\n  console.log('No scan_guid found');\\n  return '';\\n}\\n\\n// Extract place_id with multiple patterns (equivalent to extract_place_id)\\nfunction extractPlaceId(html) {\\n  const patterns = [\\n    /(ChIJ[A-Za-z0-9_-]{10,})/g,\\n    /place_id[\\\"\\']?\\\\s*[:=]\\\\s*[\\\"\\']([A-Za-z0-9_-]{10,})[\\\"\\']?/i,\\n    /[\\\"\\']place_id[\\\"\\']\\\\s*:\\\\s*[\\\"\\']([A-Za-z0-9_-]{10,})[\\\"\\']?/i,\\n    /data-place-id\\\\s*=\\\\s*[\\\"\\']([A-Za-z0-9_-]{10,})[\\\"\\']?/i,\\n    /google\\\\.maps\\\\.places\\\\.PlaceId\\\\s*=\\\\s*[\\\"\\']([A-Za-z0-9_-]+)[\\\"\\']?/i,\\n    /window\\\\.place_id\\\\s*=\\\\s*[\\\"\\']([A-Za-z0-9_-]+)[\\\"\\']?/i\\n  ];\\n  \\n  for (const pattern of patterns) {\\n    const matches = html.match(pattern);\\n    if (matches) {\\n      if (pattern.global) {\\n        // For ChIJ pattern, return first valid match\\n        for (const match of matches) {\\n          if (match.startsWith('ChIJ') && match.length > 15) {\\n            console.log(`Found place_id (ChIJ): ${match}`);\\n            return match;\\n          }\\n        }\\n      } else if (matches[1] && matches[1].length >= 10) {\\n        console.log(`Found place_id: ${matches[1]}`);\\n        return matches[1];\\n      }\\n    }\\n  }\\n  \\n  console.log('No place_id found');\\n  return '';\\n}\\n\\n// Extract all JavaScript data (equivalent to extract_all_js_data)\\nconst pinzData = extractPinzData(htmlContent);\\nconst scanGuid = extractScanGuid(htmlContent);\\nconst placeId = extractPlaceId(htmlContent);\\n\\n// Additional validation\\nconst isValidGuid = scanGuid.length >= 8 && /^[a-f0-9-]+$/i.test(scanGuid);\\nconst isValidPlaceId = placeId.length >= 10;\\n\\n// Extract map data from pinz (equivalent to extract_map_data)\\nconst mapData = [];\\nif (pinzData && Array.isArray(pinzData)) {\\n  pinzData.forEach((pin, index) => {\\n    if (pin && typeof pin === 'object') {\\n      mapData.push({\\n        index: index + 1,\\n        lat: pin.location?.lat || pin.lat || null,\\n        lon: pin.location?.lon || pin.lng || pin.longitude || null,\\n        label: pin.lable || pin.label || pin.title || '',\\n        title: pin.title || '',\\n        url: pin.url || '',\\n        color: pin.color || '',\\n        rank: pin.rank || null,\\n        distance: pin.distance || null\\n      });\\n    }\\n  });\\n}\\n\\nreturn {\\n  html_content: htmlContent,\\n  javascript_data: {\\n    pinz_array: pinzData,\\n    scan_guid: scanGuid,\\n    place_id: placeId,\\n    pinz_count: pinzData.length,\\n    validation: {\\n      valid_guid: isValidGuid,\\n      valid_place_id: isValidPlaceId,\\n      html_length: htmlContent.length,\\n      has_pinz_data: pinzData.length > 0\\n    }\\n  },\\n  map_data_from_js: mapData\\n};"
      },
      "id": "extract-javascript-data",
      "name": "Extract JavaScript Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [900, 400]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.html_content }}",
        "rules": {
          "rules": [
            {
              "extractor": "css",
              "cssSelector": "h4:contains('Scan Information') + table, table[summary*='Scan Information'], .scan-info table, .business-info table",
              "returnArray": true,
              "attribute": "outerHTML"
            }
          ]
        }
      },
      "id": "extract-scan-information",
      "name": "Extract Scan Information",
      "type": "n8n-nodes-base.htmlExtract",
      "typeVersion": 1.2,
      "position": [1100, 200]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.html_content }}",
        "rules": {
          "rules": [
            {
              "extractor": "css",
              "cssSelector": "h4:contains('Rank Summary') + table, .rank-summary table",
              "returnArray": true,
              "attribute": "outerHTML"
            }
          ]
        }
      },
      "id": "extract-rank-summary",
      "name": "Extract Rank Summary",
      "type": "n8n-nodes-base.htmlExtract",
      "typeVersion": 1.2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.html_content }}",
        "rules": {
          "rules": [
            {
              "extractor": "css",
              "cssSelector": "table#tbl_comp_rank tbody tr, .competitor-row, .competitor, [class*='competitor']",
              "returnArray": true,
              "attribute": "outerHTML"
            }
          ]
        }
      },
      "id": "extract-competitors",
      "name": "Extract Competitors",
      "type": "n8n-nodes-base.htmlExtract",
      "typeVersion": 1.2,
      "position": [1100, 400]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.html_content }}",
        "rules": {
          "rules": [
            {
              "extractor": "css",
              "cssSelector": "table#tbl_ads_rank tbody tr, .sponsored-listing, .sponsored, .ad-listing, [class*='sponsored'], [class*='ad']",
              "returnArray": true,
              "attribute": "outerHTML"
            }
          ]
        }
      },
      "id": "extract-sponsored",
      "name": "Extract Sponsored",
      "type": "n8n-nodes-base.htmlExtract",
      "typeVersion": 1.2,
      "position": [1100, 500]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.html_content }}",
        "rules": {
          "rules": [
            {
              "extractor": "css",
              "cssSelector": "div#resultModal div.results_body div.bg-light.panel-body, .detailed-result, .result-detail",
              "returnArray": true,
              "attribute": "outerHTML"
            }
          ]
        }
      },
      "id": "extract-detailed-results",
      "name": "Extract Detailed Results",
      "type": "n8n-nodes-base.htmlExtract",
      "typeVersion": 1.2,
      "position": [1100, 600]
    },
    {
      "parameters": {
        "functionCode": "// Parse Scan Information (equivalent to parse_scan_information)\\nconst data = $input.first().json.data || [];\\nconst results = {};\\n\\n// Helper function to safely get text\\nfunction getText(htmlStr, selector) {\\n  if (!htmlStr) return 'N/A';\\n  try {\\n    const matches = htmlStr.match(new RegExp(`<[^>]*class[^>]*${selector}[^>]*>([^<]+)<`, 'i'));\\n    return matches ? matches[1].trim() : 'N/A';\\n  } catch (e) {\\n    return 'N/A';\\n  }\\n}\\n\\n// Helper function to extract rating and reviews\\nfunction extractRatingAndReviews(htmlStr) {\\n  let rating = 'N/A';\\n  let reviews = '0';\\n  \\n  try {\\n    // Extract rating from title\\n    const ratingMatch = htmlStr.match(/title=\\\"([0-9]+(?:[\\\\.,][0-9]+)?)\\\\s*out\\\\s*of\\\\s*5\\\"/i);\\n    if (ratingMatch) {\\n      rating = ratingMatch[1].replace(',', '.');\\n    }\\n    \\n    // Extract rating from style width\\n    if (rating === 'N/A') {\\n      const styleMatch = htmlStr.match(/width:\\\\s*([0-9]+)%/);\\n      if (styleMatch) {\\n        const pct = parseInt(styleMatch[1]);\\n        rating = (pct * 5 / 100).toFixed(1);\\n      }\\n    }\\n    \\n    // Extract review count\\n    const reviewMatch = htmlStr.match(/\\\\(?\\\\s*([0-9]+)\\\\s*(?:Reviews?|Yorum(?:lar)?|Değerlendirme)?\\\\s*\\\\)?/i);\\n    if (reviewMatch) {\\n      reviews = reviewMatch[1];\\n    }\\n  } catch (e) {\\n    console.log('Rating extraction error:', e.message);\\n  }\\n  \\n  return { rating, reviews };\\n}\\n\\nfor (const htmlStr of data) {\\n  if (typeof htmlStr === 'string') {\\n    // Extract business name\\n    const bizNameMatch = htmlStr.match(/<span[^>]*class[^>]*bizname[^>]*>([^<]+)</i);\\n    if (bizNameMatch) results['İşletme Adı'] = bizNameMatch[1].trim();\\n    \\n    // Extract address\\n    const addrMatch = htmlStr.match(/<span[^>]*class[^>]*center-block[^>]*>([^<]+)</i);\\n    if (addrMatch) results['Adres'] = addrMatch[1].trim();\\n    \\n    // Extract rating and reviews\\n    const ratingInfo = extractRatingAndReviews(htmlStr);\\n    results['Puan'] = ratingInfo.rating;\\n    results['Yorum Sayısı'] = ratingInfo.reviews;\\n    \\n    // Extract keyword and language\\n    const kwMatch = htmlStr.match(/Keyword[^<]*<\\/td>\\\\s*<td[^>]*>([^<]+)</i);\\n    if (kwMatch) results['Anahtar Kelime ve Dil'] = kwMatch[1].trim();\\n    \\n    // Extract date\\n    const dateMatch = htmlStr.match(/<td[^>]*class[^>]*cnv_dt_lcl[^>]*>([^<]+)</i);\\n    if (dateMatch) results['Tarih'] = dateMatch[1].trim();\\n  }\\n}\\n\\nreturn { scan_information: results };"
      },
      "id": "parse-scan-information",
      "name": "Parse Scan Information",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1300, 200]
    },
    {
      "parameters": {
        "functionCode": "// Parse Rank Summary (equivalent to parse_rank_summary)\\nconst data = $input.first().json.data || [];\\nconst results = {};\\n\\nfor (const htmlStr of data) {\\n  if (typeof htmlStr === 'string') {\\n    // Extract all table rows\\n    const rowMatches = htmlStr.match(/<tr[^>]*>[\\\\s\\\\S]*?<\\/tr>/gi) || [];\\n    \\n    for (const row of rowMatches) {\\n      const cellMatches = row.match(/<td[^>]*>([\\\\s\\\\S]*?)<\\/td>/gi) || [];\\n      \\n      if (cellMatches.length >= 2) {\\n        const keyCell = cellMatches[0].replace(/<[^>]*>/g, '').trim();\\n        const valueCell = cellMatches[1].replace(/<[^>]*>/g, '').trim();\\n        \\n        // Map English keys to Turkish\\n        const keyMappings = {\\n          'ranked locations': 'Ranked Locations',\\n          'average rank': 'Average rank (Ranked Locations)',\\n          'avg total rank': 'Avg total rank (All Locations)',\\n          'best rank': 'Best rank',\\n          'max distance': 'Max Distance'\\n        };\\n        \\n        const normalizedKey = keyCell.toLowerCase();\\n        for (const [pattern, turkishKey] of Object.entries(keyMappings)) {\\n          if (normalizedKey.includes(pattern)) {\\n            results[turkishKey] = valueCell;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n  }\\n}\\n\\nreturn { rank_summary: results };"
      },
      "id": "parse-rank-summary",
      "name": "Parse Rank Summary",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "functionCode": "// Parse Competitors (equivalent to parse_competitors)\\nconst data = $input.first().json.data || [];\\nconst competitors = [];\\n\\n// Helper function to safely get text\\nfunction getText(htmlStr, pattern) {\\n  try {\\n    const match = htmlStr.match(pattern);\\n    return match ? match[1].trim() : 'N/A';\\n  } catch (e) {\\n    return 'N/A';\\n  }\\n}\\n\\n// Helper function to extract rating and reviews\\nfunction extractRatingAndReviews(htmlStr) {\\n  let rating = 'N/A';\\n  let reviews = '0';\\n  let combined = 'N/A';\\n  \\n  try {\\n    // Extract rating\\n    const ratingMatch = htmlStr.match(/title=\\\"([0-9]+(?:[\\\\.,][0-9]+)?)\\\\s*out\\\\s*of\\\\s*5\\\"/i);\\n    if (ratingMatch) {\\n      rating = ratingMatch[1].replace(',', '.');\\n    } else {\\n      // Try style width\\n      const styleMatch = htmlStr.match(/width:\\\\s*([0-9]+)%/);\\n      if (styleMatch) {\\n        const pct = parseInt(styleMatch[1]);\\n        rating = (pct * 5 / 100).toFixed(1);\\n      }\\n    }\\n    \\n    // Extract reviews\\n    const reviewMatch = htmlStr.match(/\\\\(?\\\\s*([0-9]+)\\\\s*(?:Reviews?|Yorum)?\\\\s*\\\\)?/i);\\n    if (reviewMatch) {\\n      reviews = reviewMatch[1];\\n    }\\n    \\n    // Create combined format\\n    if (rating !== 'N/A' && reviews !== '0') {\\n      combined = `${rating} (${reviews})`;\\n    } else if (rating !== 'N/A') {\\n      combined = rating;\\n    } else {\\n      combined = 'N/A';\\n    }\\n  } catch (e) {\\n    console.log('Rating extraction error:', e.message);\\n  }\\n  \\n  return { rating, reviews, combined };\\n}\\n\\nfor (const htmlStr of data) {\\n  if (typeof htmlStr === 'string') {\\n    const comp = {};\\n    \\n    // Extract name\\n    comp['İsim'] = getText(htmlStr, /<a[^>]*class[^>]*ext[^>]*>([^<]+)</i);\\n    \\n    // Extract rating and reviews\\n    const ratingInfo = extractRatingAndReviews(htmlStr);\\n    comp['Puan'] = ratingInfo.rating;\\n    comp['Yorum Sayısı'] = ratingInfo.reviews;\\n    comp['Puan/Yorum'] = ratingInfo.combined;\\n    \\n    // Extract address\\n    comp['Adres'] = getText(htmlStr, /<i[^>]*class[^>]*fa-map-marker[^>]*><\\/i>[\\\\s\\\\S]*?<span[^>]*>([^<]+)</i);\\n    \\n    // Extract categories\\n    comp['Kategoriler'] = getText(htmlStr, /Categories:[^<]*<[^>]*>([^<]+)</i);\\n    \\n    // Extract website\\n    const websiteMatch = htmlStr.match(/<i[^>]*class[^>]*fa-globe[^>]*>[\\\\s\\\\S]*?<a[^>]*href=\\\"([^\\\"]+)\\\"/i);\\n    comp['Web Sitesi'] = websiteMatch ? websiteMatch[1] : 'N/A';\\n    \\n    // Extract photos count\\n    comp['Fotoğraf Sayısı'] = getText(htmlStr, /<i[^>]*class[^>]*fa-photo[^>]*><\\/i>[\\\\s\\\\S]*?<span[^>]*>([^<]+)</i);\\n    \\n    // Extract claim status\\n    const claimMatch = htmlStr.match(/((?:Un\\\\s*)?Claimed)/i);\\n    comp['Sahiplenme Durumu'] = claimMatch ? claimMatch[1] : 'N/A';\\n    \\n    // Extract location count\\n    comp['Bulunduğu Konum Sayısı'] = getText(htmlStr, /<td[^>]*class[^>]*text-center[^>]*><h5[^>]*>([^<]+)</i);\\n    \\n    // Extract average ranking\\n    comp['Ortalama Sıralama'] = getText(htmlStr, /<span[^>]*class[^>]*dotlg2[^>]*>([^<]+)</i);\\n    \\n    // Only add if we have a name\\n    if (comp['İsim'] && comp['İsim'] !== 'N/A') {\\n      competitors.push(comp);\\n    }\\n  }\\n}\\n\\nreturn { competitors: competitors };"
      },
      "id": "parse-competitors",
      "name": "Parse Competitors",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1300, 400]
    },
    {
      "parameters": {
        "functionCode": "// Parse Sponsored Listings (equivalent to parse_sponsorlu_listeler)\\nconst data = $input.first().json.data || [];\\nconst listings = [];\\n\\n// Helper function to safely get text\\nfunction getText(htmlStr, pattern) {\\n  try {\\n    const match = htmlStr.match(pattern);\\n    return match ? match[1].trim() : 'N/A';\\n  } catch (e) {\\n    return 'N/A';\\n  }\\n}\\n\\n// Helper function to extract rating and reviews\\nfunction extractRatingAndReviews(htmlStr) {\\n  let rating = 'N/A';\\n  let reviews = '0';\\n  let combined = 'N/A';\\n  \\n  try {\\n    // Extract rating\\n    const ratingMatch = htmlStr.match(/title=\\\"([0-9]+(?:[\\\\.,][0-9]+)?)\\\\s*out\\\\s*of\\\\s*5\\\"/i);\\n    if (ratingMatch) {\\n      rating = ratingMatch[1].replace(',', '.');\\n    }\\n    \\n    // Extract reviews\\n    const reviewMatch = htmlStr.match(/\\\\(?\\\\s*([0-9]+)\\\\s*(?:Reviews?|Yorum)?\\\\s*\\\\)?/i);\\n    if (reviewMatch) {\\n      reviews = reviewMatch[1];\\n    }\\n    \\n    // Create combined format\\n    if (rating !== 'N/A' && reviews !== '0') {\\n      combined = `${rating} (${reviews})`;\\n    } else if (rating !== 'N/A') {\\n      combined = rating;\\n    }\\n  } catch (e) {\\n    console.log('Rating extraction error:', e.message);\\n  }\\n  \\n  return { rating, reviews, combined };\\n}\\n\\nfor (const htmlStr of data) {\\n  if (typeof htmlStr === 'string') {\\n    const listing = {};\\n    \\n    // Extract name\\n    listing['İsim'] = getText(htmlStr, /<a[^>]*class[^>]*ext[^>]*>([^<]+)</i);\\n    \\n    // Extract rating and reviews\\n    const ratingInfo = extractRatingAndReviews(htmlStr);\\n    listing['Puan'] = ratingInfo.rating;\\n    listing['Yorum Sayısı'] = ratingInfo.reviews;\\n    listing['Puan/Yorum'] = ratingInfo.combined;\\n    \\n    // Extract appearance count\\n    const tdMatches = htmlStr.match(/<td[^>]*>([\\\\s\\\\S]*?)<\\/td>/gi) || [];\\n    if (tdMatches.length > 0) {\\n      const lastTd = tdMatches[tdMatches.length - 1];\\n      const appearanceText = lastTd.replace(/<[^>]*>/g, '').trim();\\n      listing['Görülme Sayısı'] = appearanceText || 'N/A';\\n    } else {\\n      listing['Görülme Sayısı'] = 'N/A';\\n    }\\n    \\n    // Only add if we have a name\\n    if (listing['İsim'] && listing['İsim'] !== 'N/A') {\\n      listings.push(listing);\\n    }\\n  }\\n}\\n\\nreturn { sponsored_listings: listings };"
      },
      "id": "parse-sponsored",
      "name": "Parse Sponsored",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1300, 500]
    },
    {
      "parameters": {
        "functionCode": "// Parse Detailed Results (equivalent to parse_detayli_sonuclar)\\nconst data = $input.first().json.data || [];\\nconst detaylar = [];\\n\\n// Helper function to safely get text\\nfunction getText(htmlStr, pattern) {\\n  try {\\n    const match = htmlStr.match(pattern);\\n    return match ? match[1].trim() : 'N/A';\\n  } catch (e) {\\n    return 'N/A';\\n  }\\n}\\n\\n// Helper function to extract rating and reviews\\nfunction extractRatingAndReviews(htmlStr) {\\n  let rating = 'N/A';\\n  let reviews = '0';\\n  let combined = 'N/A';\\n  \\n  try {\\n    const ratingMatch = htmlStr.match(/title=\\\"([0-9]+(?:[\\\\.,][0-9]+)?)\\\\s*out\\\\s*of\\\\s*5\\\"/i);\\n    if (ratingMatch) {\\n      rating = ratingMatch[1].replace(',', '.');\\n    }\\n    \\n    const reviewMatch = htmlStr.match(/\\\\(?\\\\s*([0-9]+)\\\\s*(?:Reviews?|Yorum)?\\\\s*\\\\)?/i);\\n    if (reviewMatch) {\\n      reviews = reviewMatch[1];\\n    }\\n    \\n    if (rating !== 'N/A' && reviews !== '0') {\\n      combined = `${rating} (${reviews})`;\\n    } else if (rating !== 'N/A') {\\n      combined = rating;\\n    }\\n  } catch (e) {\\n    console.log('Rating extraction error:', e.message);\\n  }\\n  \\n  return { rating, reviews, combined };\\n}\\n\\nfor (const htmlStr of data) {\\n  if (typeof htmlStr === 'string') {\\n    const detail = {};\\n    \\n    // Extract rank\\n    detail['Sıra'] = getText(htmlStr, /<span[^>]*class[^>]*dot[^>]*>([^<]+)</i);\\n    \\n    // Extract name\\n    detail['İsim'] = getText(htmlStr, /<h5[^>]*>([^<]+)</i);\\n    \\n    // Extract rating and reviews\\n    const ratingInfo = extractRatingAndReviews(htmlStr);\\n    detail['Puan'] = ratingInfo.rating;\\n    detail['Yorum Sayısı'] = ratingInfo.reviews;\\n    detail['Puan/Yorum'] = ratingInfo.combined;\\n    \\n    // Extract address (more complex extraction)\\n    const divMatches = htmlStr.match(/<div[^>]*>([\\\\s\\\\S]*?)<\\/div>/gi) || [];\\n    let address = 'N/A';\\n    for (const div of divMatches) {\\n      const text = div.replace(/<[^>]*>/g, '').trim();\\n      if (text && text.length > 10 && !text.includes('rating') && !text.includes('Reviews')) {\\n        address = text;\\n        break;\\n      }\\n    }\\n    detail['Adres'] = address;\\n    \\n    // Only add if we have meaningful data\\n    if ((detail['Sıra'] && detail['Sıra'] !== 'N/A') || (detail['İsim'] && detail['İsim'] !== 'N/A')) {\\n      detaylar.push(detail);\\n    }\\n  }\\n}\\n\\nreturn { detailed_results: detaylar };"
      },
      "id": "parse-detailed-results",
      "name": "Parse Detailed Results",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1300, 600]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ 'https://www.local-rank.report/scans/get-analytics-data?scan_guid=' + ($json.javascript_data?.scan_guid || 'default-guid') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            },
            {
              "name": "Referer",
              "value": "={{ $('Fetch HTML - Primary').item.json.url || 'https://www.local-rank.report' }}"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "responseFormat": "autodetect"
          }
        }
      },
      "id": "api-analytics-data",
      "name": "API - Analytics Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 750]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "={{ 'https://www.local-rank.report/scans/get-competitors-list?scan_guid=' + ($json.javascript_data?.scan_guid || 'default-guid') }}",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            {
              "name": "Accept",
              "value": "application/json,text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "response": {
            "responseFormat": "autodetect"
          }
        }
      },
      "id": "api-competitors-data",
      "name": "API - Competitors Data",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1100, 850]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-scan-rank",
      "name": "Merge Scan + Rank",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1500, 250]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-competitors-sponsored",
      "name": "Merge Competitors + Sponsored",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1500, 450]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-detailed-api",
      "name": "Merge Detailed + API",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1500, 700]
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "id": "merge-all-parsed",
      "name": "Merge All Parsed Data",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1700, 400]
    },
    {
      "parameters": {
        "functionCode": "// Combine All Data - Full Version (equivalent to MainScraper.scrape_all + DataExporter)\\n// This combines all parsed data into the final structure\\n\\nconst allInputs = $input.all();\\n\\n// Extract data from all inputs\\nconst jsData = allInputs.find(item => item.json.javascript_data)?.json.javascript_data || {};\\nconst scanInfo = allInputs.find(item => item.json.scan_information)?.json.scan_information || {};\\nconst rankSummary = allInputs.find(item => item.json.rank_summary)?.json.rank_summary || {};\\nconst competitors = allInputs.find(item => item.json.competitors)?.json.competitors || [];\\nconst sponsoredListings = allInputs.find(item => item.json.sponsored_listings)?.json.sponsored_listings || [];\\nconst detailedResults = allInputs.find(item => item.json.detailed_results)?.json.detailed_results || [];\\nconst mapDataFromJs = allInputs.find(item => item.json.map_data_from_js)?.json.map_data_from_js || [];\\nconst analyticsData = allInputs.find(item => item.json.analytics_data)?.json || {};\\nconst competitorsApiData = allInputs.find(item => item.json.competitors_api_data)?.json || {};\\nconst htmlContent = allInputs.find(item => item.json.html_content)?.json.html_content || '';\\n\\n// Combine scan information and rank summary (equivalent to ozet_bilgiler)\\nconst ozetBilgiler = {\\n  ...scanInfo,\\n  ...rankSummary\\n};\\n\\n// Enhanced map data combining JS and HTML sources\\nconst enhancedMapData = [...mapDataFromJs];\\n\\n// Enhanced API data structure\\nconst enhancedApiData = {\\n  analytics_data: Array.isArray(analyticsData) ? analyticsData : [analyticsData].filter(Boolean),\\n  competitors_data: Array.isArray(competitorsApiData) ? competitorsApiData : [competitorsApiData].filter(Boolean),\\n  ranking_data: [],\\n  last_updated: new Date().toISOString()\\n};\\n\\n// Enhanced JavaScript data with full validation\\nconst enhancedJsData = {\\n  pinz: jsData.pinz_array || [],\\n  scan_guid: jsData.scan_guid || '',\\n  place_id: jsData.place_id || '',\\n  ...jsData\\n};\\n\\n// Create metadata (equivalent to MainScraper metadata)\\nconst metadata = {\\n  scraped_at: new Date().toISOString(),\\n  url: $('Fetch HTML - Primary').item?.json?.url || 'Unknown',\\n  scraper_version: '5.0-full',\\n  method: 'n8n_modular_hybrid_full',\\n  selenium_used: false, // Set to true if Selenium fallback was used\\n  total_competitors: competitors.length,\\n  total_sponsored: sponsoredListings.length,\\n  total_detailed_results: detailedResults.length,\\n  total_map_points: enhancedMapData.length,\\n  parsing_success: {\\n    js_data: Object.keys(jsData).length > 0,\\n    competitors: competitors.length > 0,\\n    sponsored: sponsoredListings.length > 0,\\n    summary: Object.keys(ozetBilgiler).length > 0,\\n    detailed_results: detailedResults.length > 0,\\n    api_data: Object.keys(enhancedApiData).length > 0\\n  },\\n  data_quality: {\\n    html_length: htmlContent.length,\\n    has_scan_guid: !!jsData.scan_guid,\\n    has_place_id: !!jsData.place_id,\\n    has_pinz_data: (jsData.pinz_array || []).length > 0\\n  }\\n};\\n\\n// Final complete data structure (equivalent to Python main_scraper.py output)\\nconst finalData = {\\n  ozet_bilgiler: ozetBilgiler,\\n  rakipler: competitors,\\n  sponsorlu_listeler: sponsoredListings,\\n  detayli_sonuclar: detailedResults,\\n  harita_verileri: enhancedMapData,\\n  api_verileri: enhancedApiData,\\n  javascript_verileri: enhancedJsData,\\n  metadata: metadata\\n};\\n\\nreturn finalData;"
      },
      "id": "combine-all-data",
      "name": "Combine All Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 2,
      "position": [1900, 400]
    },
    {
      "parameters": {
        "operation": "toFile",
        "fileFormat": "xlsx",
        "options": {
          "fileName": "={{ 'local_rank_full_' + $now.format('YYYYMMDD_HHmmss') + '.xlsx' }}",
          "sheetName": "Complete Report"
        }
      },
      "id": "export-excel-full",
      "name": "Export Excel - Full",
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [2100, 300]
    },
    {
      "parameters": {
        "chatId": "={{ $json.telegram_chat_id || '@default_channel' }}",
        "text": "🏢 *Local Rank Report - FULL VERSION*\\n\\n📊 *Business:* {{ $json.ozet_bilgiler['İşletme Adı'] || 'Unknown' }}\\n📍 *Address:* {{ $json.ozet_bilgiler['Adres'] || 'N/A' }}\\n⭐ *Rating:* {{ $json.ozet_bilgiler['Puan'] || 'N/A' }}/5.0\\n💬 *Reviews:* {{ $json.ozet_bilgiler['Yorum Sayısı'] || '0' }}\\n🎯 *Best Rank:* {{ $json.ozet_bilgiler['Best rank'] || 'N/A' }}\\n\\n📈 *Detailed Analysis:*\\n🏆 Competitors: {{ $json.metadata.total_competitors }}\\n📢 Sponsored: {{ $json.metadata.total_sponsored }}\\n📋 Detailed Results: {{ $json.metadata.total_detailed_results }}\\n📍 Map Points: {{ $json.metadata.total_map_points }}\\n\\n🔍 *Technical Info:*\\n🆔 Scan GUID: {{ $json.javascript_verileri.scan_guid ? '✅' : '❌' }}\\n🗺️ Place ID: {{ $json.javascript_verileri.place_id ? '✅' : '❌' }}\\n📡 Pinz Data: {{ ($json.javascript_verileri.pinz || []).length }} points\\n\\n⚡ *Performance:*\\n📊 HTML Size: {{ ($json.metadata.data_quality.html_length / 1024).toFixed(1) }}KB\\n🎯 Success Rate: {{ Object.values($json.metadata.parsing_success).filter(Boolean).length }}/{{ Object.keys($json.metadata.parsing_success).length }}\\n\\n⏰ Report: {{ $now.format('DD.MM.YYYY HH:mm') }}\\n🔧 Version: {{ $json.metadata.scraper_version }}",
        "additionalFields": {
          "parse_mode": "Markdown"
        }
      },
      "id": "telegram-full-report",
      "name": "Telegram - Full Report",
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.1,
      "position": [2100, 400]
    },
    {
      "parameters": {},
      "id": "success-end",
      "name": "Success",
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [2300, 350]
    },
    {
      "parameters": {
        "message": "Full Local Rank Scraper failed: {{ $json.error || 'Unknown error occurred during processing' }}"
      },
      "id": "error-handler",
      "name": "Error Handler",
      "type": "n8n-nodes-base.stopAndError",
      "typeVersion": 1,
      "position": [2300, 550]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Fetch HTML - Primary",
            "type": "main",
            "index": 0
          },
          {
            "node": "Selenium Fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch HTML - Primary": {
      "main": [
        [
          {
            "node": "Check HTML Quality",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Selenium Fallback": {
      "main": [
        [
          {
            "node": "Merge HTML Sources",
            "type": "main",
            "index": 1
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Merge HTML Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Check HTML Quality": {
      "main": [
        [
          {
            "node": "Merge HTML Sources",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge HTML Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge HTML Sources": {
      "main": [
        [
          {
            "node": "Extract JavaScript Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract JavaScript Data": {
      "main": [
        [
          {
            "node": "Extract Scan Information",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Rank Summary",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Competitors",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Sponsored",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Detailed Results",
            "type": "main",
            "index": 0
          },
          {
            "node": "API - Analytics Data",
            "type": "main",
            "index": 0
          },
          {
            "node": "API - Competitors Data",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Scan Information": {
      "main": [
        [
          {
            "node": "Parse Scan Information",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Rank Summary": {
      "main": [
        [
          {
            "node": "Parse Rank Summary",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Competitors": {
      "main": [
        [
          {
            "node": "Parse Competitors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Sponsored": {
      "main": [
        [
          {
            "node": "Parse Sponsored",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Detailed Results": {
      "main": [
        [
          {
            "node": "Parse Detailed Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Scan Information": {
      "main": [
        [
          {
            "node": "Merge Scan + Rank",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Rank Summary": {
      "main": [
        [
          {
            "node": "Merge Scan + Rank",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Parse Competitors": {
      "main": [
        [
          {
            "node": "Merge Competitors + Sponsored",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Sponsored": {
      "main": [
        [
          {
            "node": "Merge Competitors + Sponsored",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Parse Detailed Results": {
      "main": [
        [
          {
            "node": "Merge Detailed + API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "API - Analytics Data": {
      "main": [
        [
          {
            "node": "Merge Detailed + API",
            "type": "main",
            "index": 1
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Merge Detailed + API",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "API - Competitors Data": {
      "main": [
        [
          {
            "node": "Merge Detailed + API",
            "type": "main",
            "index": 2
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Merge Detailed + API",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge Scan + Rank": {
      "main": [
        [
          {
            "node": "Merge All Parsed Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Competitors + Sponsored": {
      "main": [
        [
          {
            "node": "Merge All Parsed Data",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Detailed + API": {
      "main": [
        [
          {
            "node": "Merge All Parsed Data",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Merge All Parsed Data": {
      "main": [
        [
          {
            "node": "Combine All Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine All Data": {
      "main": [
        [
          {
            "node": "Export Excel - Full",
            "type": "main",
            "index": 0
          },
          {
            "node": "Telegram - Full Report",
            "type": "main",
            "index": 0
          }
        ]
      ],
      "onError": [
        [
          {
            "node": "Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Export Excel - Full": {
      "main": [
        [
          {
            "node": "Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram - Full Report": {
      "main": [
        [
          {
            "node": "Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [
    {
      "id": "local-rank-full",
      "name": "Local Rank Full"
    },
    {
      "id": "scraping-complete",
      "name": "Complete Scraping"
    },
    {
      "id": "python-equivalent",
      "name": "Python Module Equivalent"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-08T16:00:00.000Z",
  "versionId": "5.0"
}